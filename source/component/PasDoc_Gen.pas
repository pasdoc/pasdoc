{ @abstract(basic doc generator object)
  @author(Johannes Berg <johannes@sipsolutions.de>)
  @author(Ralf Junker (delphi@zeitungsjunge.de))
  @author(Ivan Montes Velencoso (senbei@teleline.es))
  @author(Marco Schmidt (marcoschmidt@geocities.com))
  @author(Philippe Jean Dit Bailleul (jdb@abacom.com))
  @author(Rodrigo Urubatan Ferreira Jardim (rodrigo@netscape.net))
  @author(Grzegorz Skoczylas <gskoczylas@rekord.pl>)
  @author(Pierre Woestyn <pwoestyn@users.sourceforge.net>)
  @author(Michalis Kamburelis)
  @author(Richard B. Winston <rbwinst@usgs.gov>)
  @author(Ascanio Pressato)
  @author(Hans-Peter Diettrich <DrDiettrich1@aol.com>)
  @created(30 Aug 1998)
  @cvs($Date$)

  @name contains the basic documentation generator object @link(TDocGenerator).
  It is not sufficient by itself but the basis for all generators that produce
  documentation in a specific format like HTML or LaTex.
  They override @link(TDocGenerator)'s virtual methods. }

unit PasDoc_Gen;

{$I pasdoc_defines.inc}

interface

uses
  Classes,
  PasDoc_Base,
  PasDoc_Items,
  PasDoc_Languages,
  PasDoc_StringVector,
  PasDoc_ObjectVector,
  PasDoc_Types,
  PasDoc_TagManager,
  PasDoc_Aspell;

type
//available sections for an item
  TSectionSet = set of TTranslationID;
//ordered list of sections in an (HTML) file menu.
  TSectionsInMenu = array[0..6] of TTranslationID;

  { Overview files that pasdoc generates for multiple-document-formats
    like HTML (see @link(TGenericHTMLDocGenerator)).

    But not all of them are supposed to be generated by pasdoc,
    some must be generated by external programs by user,
    e.g. uses and class diagrams must be made by user using programs
    such as GraphViz. See type TCreatedOverviewFile for subrange type
    of TOverviewFile that specifies only overview files that are really
    supposed to be made by pasdoc. }
  TOverviewFile = (
    ofUnits,
    ofClassHierarchy,
    ofCios,
    ofTypes,
    ofVariables,
    ofConstants,
    ofFunctionsAndProcedures,
    ofIdentifiers,
    ofGraphVizUses,
    ofGraphVizClasses );

  TCreatedOverviewFile = Low(TOverviewFile) .. ofIdentifiers;

  TOverviewFileInfo = record
    BaseFileName: string;
    TranslationId: TTranslationId;
    TranslationHeadlineId: TTranslationId;
    NoItemsTranslationId: TTranslationId;
  end;

const
  OverviewFilesInfo: array[TOverviewFile] of TOverviewFileInfo = (
    (BaseFileName: 'AllUnits'      ; TranslationId: trUnits                 ; TranslationHeadlineId: trHeadlineUnits                 ; NoItemsTranslationId: trNone { unused }  ; ),
    (BaseFileName: 'ClassHierarchy'; TranslationId: trClassHierarchy        ; TranslationHeadlineId: trClassHierarchy { no headline }; NoItemsTranslationId: trNoCIOs           ; ),
    (BaseFileName: 'AllClasses'    ; TranslationId: trCio                   ; TranslationHeadlineId: trHeadlineCio                   ; NoItemsTranslationId: trNoCIOs           ; ),
    (BaseFileName: 'AllTypes'      ; TranslationId: trTypes                 ; TranslationHeadlineId: trHeadlineTypes                 ; NoItemsTranslationId: trNoTypes          ; ),
    (BaseFileName: 'AllVariables'  ; TranslationId: trVariables             ; TranslationHeadlineId: trHeadlineVariables             ; NoItemsTranslationId: trNoVariables      ; ),
    (BaseFileName: 'AllConstants'  ; TranslationId: trConstants             ; TranslationHeadlineId: trHeadlineConstants             ; NoItemsTranslationId: trNoConstants      ; ),
    (BaseFileName: 'AllFunctions'  ; TranslationId: trFunctionsAndProcedures; TranslationHeadlineId: trHeadlineFunctionsAndProcedures; NoItemsTranslationId: trNoFunctions      ; ),
    (BaseFileName: 'AllIdentifiers'; TranslationId: trIdentifiers           ; TranslationHeadlineId: trHeadlineIdentifiers           ; NoItemsTranslationId: trNoIdentifiers    ; ),
    (BaseFileName: 'GVUses'        ; TranslationId: trGvUses                ; TranslationHeadlineId: trGvUses { no headline }        ; NoItemsTranslationId: trNone { unused }  ; ),
    (BaseFileName: 'GVClasses'     ; TranslationId: trGvClasses             ; TranslationHeadlineId: trGvClasses { no headline }     ; NoItemsTranslationId: trNoCIOs { unused }; )
  );

  { Using High(TCreatedOverviewFile) or High(Overview)
    where Overview: TCreatedOverviewFile
    in PasDoc_GenHtml produces internal error in FPC 2.0.0.
    Same for Low(TCreatedOverviewFile).

    This is submitted as FPC bug 4140,
    [http://www.freepascal.org/bugs/showrec.php3?ID=4140].
    Fixed in FPC 2.0.1 and FPC 2.1.1. }
  LowCreatedOverviewFile = Low(TCreatedOverviewFile);
  HighCreatedOverviewFile = High(TCreatedOverviewFile);

type
  { Result for @link(TDocGenerator.CreateStream) }
  TCreateStreamResult = (
    { normal result }
    csCreated,
    { if file exists this will be returned, unless overwrite is true }
    csExisted,
    { returned on error }
    csError
  );

  { This is used by @link(TDocGenerator.MakeItemLink) }
  TLinkContext = (
    { This means that link is inside some larger code piece,
      e.g. within FullDeclaration of some item etc.
      This means that we @italic(may) be inside a context where
      used font has constant width. }
    lcCode,
    { This means that link is inside some "normal" description text. }
    lcNormal);

  TListType = (ltUnordered, ltOrdered, ltDefinition);

  TListItemSpacing = (lisCompact, lisParagraph);

  { Collected information about @@xxxList item. }
  TListItemData = class
  private
    FItemLabel: string;
    FText: string;
    FIndex: Integer;
  public
    constructor Create(AItemLabel, AText: string; AIndex: Integer);

    { This is only for @@definitionList: label for this list item,
      taken from @@itemLabel. Already in the processed form.
      For other lists this will always be ''. }
    property ItemLabel: string read FItemLabel;

    { This is content of this item, taken from @@item.
      Already in the processed form, after
      @link(TDocGenerator.ConvertString) etc.
      Ready to be included in final documentation. }
    property Text: string read FText;

    { Number of this item. This should be used for @@orderedList.
      When you iterate over @code(TListData.Items), you should be aware that
      Index of list item is @italic(not) necessarily equal
      to the position of item inside @code(TListData.Items).
      That's because of @@itemSetNumber tag.

      Normal list numbering (when no @@itemSetNumber tag was used)
      starts from 1. Using @@itemSetNumber user is able to change
      following item's Index.

      For unordered and definition lists this is simpler:
      Index is always equal to the position within @code(TListData.Items)
      (because @@itemSetNumber is not allowed there).
      And usually you will just ignore Index of items on
      unordered and definition lists. }
    property Index: Integer read FIndex;
  end;

  { Collected information about @@xxxList content. Passed to
    @link(TDocGenerator.FormatList). Every item of this list
    should be non-nil instance of @link(TListItemData). }
  TListData = class(TObjectVector)
  private
    { This is used inside list tags' handlers
      to calculate TListItemData.Index fields. }
    NextItemIndex: Integer;

    { This is only for @@definitionList.
      This is already expanded (by TTagManager.Execute) parameter
      of @@itemLabel tag, or '' if there is no pending (pending =
      not included in some @link(TListItemData)) @@itemLabel content. }
    LastItemLabel: string;

    FItemSpacing: TListItemSpacing;
    FListType: TListType;
  public
    property ItemSpacing: TListItemSpacing read FItemSpacing;
    property ListType: TListType read FListType;
    constructor Create(AOwnsObject: boolean); override;
  end;

  { Collected information about @@row (or @@rowHead). }
  TRowData = class
  public
    { @true if this is for @@rowHead tag. }
    Head: boolean;

    { Each item on this list is already converted
      (with @@-tags parsed, converted by ConvertString etc.)
      content of given cell tag. }
    Cells: TStringList;

    constructor Create;
    destructor Destroy; override;
  end;

  { Collected information about @@table. Passed to
    @link(TDocGenerator.FormatTable). Every item of this list
    should be non-nil instance of @link(TRowData). }
  TTableData = class(TObjectVector)
  private
    FMaxCellCount: Cardinal;
    FMinCellCount: Cardinal;
    procedure CalculateCellCount;
  public
    { Maximum Cells.Count, considering all rows. }
    property MaxCellCount: Cardinal read FMaxCellCount;

    { Minimum Cells.Count, considering all rows. }
    property MinCellCount: Cardinal read FMinCellCount;
  end;

  { @abstract(basic documentation generator object)
    This abstract object will do the complete process of writing
    documentation files.
    It will be given the collection of units that was the result of the
    parsing process and a configuration object that was created from default
    values and program parameters.
    Depending on the output format, one or more files may be created (HTML
    will create several, Tex only one). }
  TDocGenerator = class(TPasDocGen)
  private
    FAspellProcess: TAspellProcess;
    { the output stream that is currently written to; depending on the
      output format, more than one output stream will be necessary to
      store all documentation }
    FCurrentStream: TStream;
    { These fields are available only for tags OnExecute handlers.
      They are set in ExpandDescription. }
    FCurrentItem: TBaseItem;
    OrderedListTag, UnorderedListTag, DefinitionListTag,
      TableTag, RowTag, RowHeadTag: TTag;
  //reusable object
    FTagManager: TTagManager;
    TagCache: TObjectVector;
    procedure InitTagMgr;
    procedure InitTags(Item: TBaseItem);
    procedure AddTags;  //(TagManager: TTagManager);
    procedure ClearTags;

    { This just calls OnMessage (if assigned), but it appends
      to AMessage FCurrentItem.QualifiedName. }
    procedure DoMessageFromExpandDescription(
      const MessageType: TPasDocMessageType; const AMessage: string;
      const AVerbosity: Cardinal);

    procedure TryAutoLink(TagManager: TTagManager;
      const QualifiedIdentifier: TNameParts;
      out QualifiedIdentifierReplacement: string;
      var AutoLinked: boolean);

    function SplitSectionTagParameters(
      ThisTag: TTag; const TagParameter: string; DoMessages: boolean;
      out HeadingLevel: integer; out AnchorName: string; out Caption: string):
      boolean;

  //@groupbegin(tags Tag Handlers)
    procedure HandleLinkTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleLongCodeTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleClassnameTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleHtmlTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleLatexTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleInheritedClassTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleInheritedTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleNameTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleCodeTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleLiteralTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleBrTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure PreHandleSectionTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleSectionTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure PreHandleAnchorTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleAnchorTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleBoldTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleItalicTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandlePreformattedTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleImageTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleIncludeTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleOrderedListTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleUnorderedListTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleDefinitionListTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleItemTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleItemLabelTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleItemSpacingTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleItemSetNumberTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleTableTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleSomeRowTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
    procedure HandleCellTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleNoAutoLinkTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);

    procedure HandleTableOfContentsTag(ThisTag: TTag; var ThisTagData: TObject;
      EnclosingTag: TTag; var EnclosingTagData: TObject;
      const TagParameter: string; var ReplaceStr: string);
  //<@groupend

    procedure TagAllowedInsideLists(
      ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
    procedure ItemLabelTagAllowedInside(
      ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
    procedure TagAllowedInsideTable(
      ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
    procedure TagAllowedInsideRows(
      ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);

  protected
    FClassHierarchy: TDescriptionItem;

    procedure DoError(const AMessage: string; const AArguments: array of const;
      const AExitCode: Word);
    procedure DoMessage(const AVerbosity: Cardinal;
      const MessageType: TPasDocMessageType; const AMessage: string;
      const AArguments: array of const);

    procedure CreateClassHierarchy;

    { Return a link to item Item which will be displayed as LinkCaption.
      Returned string may be directly inserted inside output documentation.
      LinkCaption will be always converted using ConvertString before writing,
      so don't worry about doing this yourself when calling this method.

      LinkContext may be used in some descendants to present
      the link differently, see @link(TLinkContext) for it's meaning.

      If some output format doesn't support this feature,
      it can return simply ConvertString(LinkCaption).
      This is the default implementation of this method in this class. }
    function MakeItemLink(const Item: TBaseItem;
      const LinkCaption: string;
      const LinkContext: TLinkContext): string; virtual;

    { This writes Code as a Pascal code.
      Links inside the code are resolved from Item.
      If WriteItemLink then Item.Name is made a link.
      Item.Name is printed between NameLinkBegin and NameLinkEnd. }
    procedure WriteCodeWithLinksCommon(const Item: TPasItem;
      const Code: string; WriteItemLink: boolean;
      const NameLinkBegin, NameLinkEnd: string);
  protected
    FCurrentFileName: string;

  //Create private (shrinkable) unit list.
    procedure SetUnits(U: TPasUnits);

    { If @link(CurrentStream) still exists (<> nil), it is closed.
      Then, a new output stream in the destination directory with given
      name and file extension typical for this document format is created and
      assigned to @link(CurrentStream).
      No path or extension should therefore be in Name.
      Typical values for Name would be 'Objects' or 'AllUnits'.
      Returns true if creation was successful, false otherwise. }
    function CreateStream(const AName: string; const AOverwrite: boolean):
      TCreateStreamResult;
    { If field @link(CurrentStream) is assigned, it is disposed and set to nil. }
    procedure CloseStream;

    { the output stream that is currently written to; depending on the
      output format, more than one output stream will be necessary to
      store all documentation }
    property CurrentStream: TStream read FCurrentStream;

  protected
  //@groupbegin(abstracts Abstract Tag Formatters)
    { @abstract(Makes a String look like a coded String,
      i.e. <CODE>TheString</CODE> in Html.)
      @param(s is the string to format)
      @returns(the formatted string) }
    function CodeString(const s: string): string; virtual; abstract;

    { Converts for each character in S, thus assembling a
      String that is returned and can be written to the documentation file.

      The @@ character should not be converted, this will be done later on.
    }
    function ConvertString(const s: string): string; virtual; abstract;
    { Converts a character to its converted form. This method
      should always be called to add characters to a string.

      @@ should also be converted by this routine.
    }
    function ConvertChar(c: char): string; virtual; abstract;

    // @name writes a section heading and a link-anchor;
    function FormatSection(HL: integer; const Anchor: string;
      const Caption: string): string; virtual; abstract;

    // @name writes a link-anchor;
    function FormatAnchor(const Anchor: string): string; virtual; abstract;

    { Format a list from given ListData. }
    function FormatList(ListData: TListData): string; virtual; abstract;

    { This should return appropriate content for given Table.
      It's guaranteed that the Table passed here will have
      at least one row and in each row there will be at least
      one cell, so you don't have to check it within descendants. }
    function FormatTable(Table: TTableData): string; virtual; abstract;
  //<@groupend

    { Searches for an email address in String S. Searches for first appearance
      of the @@ character}
    function ExtractEmailAddress(s: string; out S1, S2, EmailAddress: string): Boolean;

    { Searches for a web address in String S. It must either contain a http:// or
      start with www. }
    function ExtractWebAddress(s: string; out S1, S2, WebAddress: string): Boolean;

  (* Collect all available sections for an item.
    Could become a item method?
  *)
    function  FindSections(item: TDescriptionItem): TSectionSet;
    {** Does the item have any description items?}
    function HasDescription(const AItem: TPasItem): boolean;
    //Does the item have any members with description items?
    function HasDescriptions(c: TPasItems): boolean;

    {@name returns ' abstract', or ' sealed' for classes that abstract
     or sealed respectively.  @name is used by @link(TTexDocGenerator) and
     @link(TGenericHTMLDocGenerator) in writing the declaration of the class.}
    function GetClassDirectiveName(Directive: TClassDirective): string;

    {@name writes a translation of MyType based on the current language.
     However, 'record' and 'packed record' are not translated.}
    function GetCIOTypeName(MyType: TCIOType): string;

    { Searches for item with name S.

      If S is not splittable by SplitNameParts, returns nil.
      If WarningIfNotSplittable, additionally does
      DoMessage with appropriate warning.

      Else (if S is "splittable"), seeks for S (first trying Item.FindName,
      if Item is not nil, then trying FindGlobal). Returns nil if not found. }
    function SearchItem(s: string; const Item: TBaseItem;
      WarningIfNotSplittable: boolean): TBaseItem;

    { Searches for an item of name S which was linked in the description
      of Item. Starts search within item, then does a search on all items in all
      units using @link(FindGlobal).
      Returns a link as String on success.

      If S is not splittable by SplitNameParts, it always does
      DoMessage with appropriate warning and returns something like 'UNKNOWN'
      (no matter what is the value of WarningIfLinkNotFound).
      FoundItem will be set to nil in this case.

      When item will not be found then:
      @unorderedList(
        @item(
          if WarningIfLinkNotFound is true then it returns
          CodeString(ConvertString(S)) and
          makes DoMessage with appropriate warning.)
        @item(else it returns '' (and does not do any DoMessage))
      )

      If LinkDisplay is not '', then it specifies explicite the display text for
      link. Else how exactly link does look like is controlled by
      @link(LinkLook) property.

      @param(FoundItem is the found item instance or nil if not found.) }
    function SearchLink(s: string; const Item: TBaseItem;
      const LinkDisplay: string;
      const WarningIfLinkNotFound: boolean;
      out FoundItem: TBaseItem): string; overload;

    { Just like previous overloaded version, but this doesn't return
      FoundItem (in case you don't need it). }
    function SearchLink(s: string; const Item: TBaseItem;
      const LinkDisplay: string;
      const WarningIfLinkNotFound: boolean): string; overload;

    { Writes S to CurrentStream, converting it using @link(ConvertString).
      Then optionally writes LineEnding. }
    procedure WriteConverted(const s: string; Newline: boolean); overload;

    { Writes S to CurrentStream, converting it using @link(ConvertString).
      No LineEnding at the end. }
    procedure WriteConverted(const s: string); overload;

    { Writes S to CurrentStream, converting it using @link(ConvertString).
      Then writes LineEnding. }
    procedure WriteConvertedLine(const s: string);

    { Simply writes T to CurrentStream, with optional LineEnding. }
    procedure WriteDirect(const t: string; Newline: boolean); overload;

    { Simply writes T to CurrentStream. }
    procedure WriteDirect(const t: string); overload;

    { Simply writes T followed by LineEnding to CurrentStream. }
    procedure WriteDirectLine(const t: string);

  {$IFnDEF detailed}
    { Writes all documentation for a single unit U to
      output, starting at heading level HL. }
    procedure WriteUnit(const HL: integer; const U: TPasUnit); virtual;
      abstract;
  {$ELSE}
  {@groupbegin(wrnolist Write simple item properties)}
    procedure WriteDate(HL: integer; AItem: TDescriptionItem); virtual;
  //Write the declaration of a PasItem.
    procedure WriteDeclaration(HL: integer; AItem: TDescriptionItem; PasItem: TPasItem); virtual;
  //Write a function Result description.
    procedure WriteReturnDesc(HL: integer; AItem: TDescriptionItem); virtual;
  //Write a link to the containing unit, if possible.
  //Automatism for items residing in the unit file itself?
    procedure WriteUnitRef(HL: integer; AItem: TDescriptionItem); virtual;
  {@groupend}
  {@groupbegin(wrlists Write lists of item properties)}
  //Write a list of authors, with their addresses if given.
    procedure WriteAuthors(HL: integer; Items: TDescriptionItem); virtual;
  //Write the ancestor list, with links if possible.
    procedure WriteHierarchy(HL: integer; Items: TDescriptionItem; AScope: TPasItem); virtual;
  //Write a list of non-PasItem members.
    procedure WriteParams(HL: integer; AItem: TDescriptionItem; AScope: TPasItem); virtual;
  //Write a list of links to PasItems (exception classes).
    procedure WriteRaises(HL: integer; AItem: TDescriptionItem; AScope: TPasItem); virtual;
  //Write a list of links to other items.
    procedure WriteSeeAlso(HL: integer; AItem: TDescriptionItem;
      AScope: TPasScope); virtual;
  //Write a list of used units, with links if possible.
    procedure WriteUnitUses(HL: integer; AItem: TDescriptionItem; AScope: TPasItem); virtual;
  //Write a list of (enum) members.
    procedure WriteValueList(HL: integer; AItem: TDescriptionItem); virtual;
  {@groupend}
  {@groupbegin(wrcomplex Write complex item properties)}
  //Write the abstract+detailed description, optionally more attributes/directives.
  //@param(AItem maybe @nil, when in a short description no item is available.)
  //@param(PasItem should be used in the first place, unless it's @nil.)
    procedure WriteDescription(HL: integer; AItem: TDescriptionItem; PasItem: TPasItem); virtual; //abstract;
    procedure WriteOverview(HL: integer; AList: TDescriptionItem;
      AScope: TPasScope); virtual;
  //Write unknown description item (show message)
    procedure WriteOther(HL: integer; AItem: TDescriptionItem;
      PasItem: TPasItem); virtual;
  {@groupend}

  //Write all description items of an item. A simple loop over all items.
    procedure WriteAllSections(HL: integer; Items: TDescriptionItem; PasItem: TPasItem);

  //Write all item description sections.
  //Omit AItem? Currently only used for PasItems!
    procedure WriteItem(HL: integer; AItem: TDescriptionItem;
      PasItem: TPasScope); virtual;

    //Write file header, if required
    procedure WriteItemHeader(HL: integer; AItem: TPasItem); virtual;
    procedure WriteDescriptionItem(HL: integer; AItem: TDescriptionItem;
      PasItem: TPasItem); virtual;

    {Write file footer, if required.
      Also write output files for all items in different files. }
    procedure WriteItemFooter(HL: integer; AItem: TPasItem); virtual;
  {$ENDIF}

  //Get (possibly qualified) section heading.
    function GetMemberSectionHeading(items: TDescriptionItem): string;

    { Writes documentation for all units, calling @link(WriteUnit) for each
      unit. }
    procedure WriteUnits(const HL: integer);

    { output graphviz uses tree }
    procedure WriteGVUses;
    { output graphviz class tree }
    procedure WriteGVClasses;

  //@groupbegin(spelling Spell Checking)
    { starts the spell checker }
    procedure StartSpellChecking(const AMode: string);

    { If CheckSpelling and spell checking was successfully started,
      this will run @link(TAspellProcess.CheckString FAspellProcess.CheckString)
      and will report all errors using DoMessage with mtWarning.

      Otherwise this just clears AErrors, which means that no errors
      were found. }
    procedure CheckString(const AString: string; const AErrors: TObjectVector);

    { closes the spellchecker }
    procedure EndSpellChecking;
  //<@groupend

  {@groupbegin(tagfmt Virtual Tag Formatters)}
    { This returns Text formatted using bold font.

      Given Text is already in the final output format
      (with characters converted using @link(ConvertString), @@-tags
      expanded etc.).

      Implementation of this method in this class simply returns
      @code(Result := Text). Output generators that can somehow express bold
      formatting (or at least emphasis of some text) should override this.

      @seealso(FormatItalic) }
    function FormatBold(const Text: string): string; virtual;

    { This returns Text formatted using italic font.
      Analogous to @link(FormatBold). }
    function FormatItalic(const Text: string): string; virtual;

    { This returns Text preserving spaces and line breaks.
      Note that Text passed here is not yet converted with ConvertString.
      The implementation of this method in this class just returns
      ConvertString(Text). }
    function FormatPreformatted(const Text: string): string; virtual;

    { This should return markup upon including specified image in description.
      FileNames is a list of alternative filenames of an image,
      it always contains at least one item (i.e. FileNames.Count >= 1),
      never contains empty lines (i.e. Trim(FileNames[I]) <> ''),
      and contains only absolute filenames (already expanded to take description's
      unit's path into account).

      E.g. HTML generator will want to choose the best format for HTML,
      then somehow copy the image from FileNames[Chosen] and wrap
      this in <img src="...">.

      Implementation of this method in this class simply returns
      @code(Result := ExpandFileName(FileNames[0])). Output generators should override this. }
    function FormatImage(FileNames: TStringList): string; virtual;

    { Override this if you want to insert something on @@tableOfContents tag.
      As a parameter you get already prepared tree of sections that your
      table of contents should show. Each item of Sections is a section
      on the level 1. Item's Name is section name, item's Value
      is section caption, item's Data is a TStringPairVector instance
      that describes subsections (on level 2) below this section.
      And so on, recursively.

      Sections given here are never nil, and item's Data is never nil.
      But of course they may contain 0 items, and this should be a signal
      to you that given section doesn't have any subsections.

      Default implementation of this method in this class just returns
      empty string. }
    function FormatTableOfContents(Sections: TDescriptionItem): string; virtual;
    { FormatPascalCode will cause Line to be formatted in
      the way that Pascal code is formatted in Delphi.
      Note that given Line is taken directly from what user put
      inside @longcode(), it is not even processed by ConvertString.
      You should process it with ConvertString if you want. }
    function FormatPascalCode(const Line: string): string; virtual;

    { This will cause AString to be formatted in the way that normal
      Pascal statements (not keywords, strings, comments, etc.)
      look in Delphi. }
    function FormatNormalCode(AString: string): string; virtual;

    // FormatComment will cause AString to be formatted in
    // the way that comments other than compiler directives are
    // formatted in Delphi.  See: @link(FormatCompilerComment).
    function FormatComment(AString: string): string; virtual;

    // FormatHex will cause AString to be formatted in
    // the way that Hex are formatted in Delphi.
    function FormatHex(AString: string): string; virtual;

    // FormatNumeric will cause AString to be formatted in
    // the way that Numeric are formatted in Delphi.
    function FormatNumeric(AString: string): string; virtual;

    // FormatFloat will cause AString to be formatted in
    // the way that Float are formatted in Delphi.
    function FormatFloat(AString: string): string; virtual;

    // FormatString will cause AString to be formatted in
    // the way that strings are formatted in Delphi.
    function FormatString(AString: string): string; virtual;

    // FormatKeyWord will cause AString to be formatted in
    // the way that reserved words are formatted in Delphi.
    function FormatKeyWord(AString: string): string; virtual;

    // FormatCompilerComment will cause AString to be formatted in
    // the way that compiler directives are formatted in Delphi.
    function FormatCompilerComment(AString: string): string; virtual;

    { This is paragraph marker in output documentation.

      Default implementation in this class simply returns ' '
      (one space). }
    function Paragraph: string; virtual;

    { See @link(TTagManager.ShortDash). Default implementation in this
      class returns '-'. }
    function ShortDash: string; virtual;

    { See @link(TTagManager.EnDash). Default implementation in this
      class returns '@--'. }
    function EnDash: string; virtual;

    { See @link(TTagManager.EmDash). Default implementation in this
      class returns '@-@--'. }
    function EmDash: string; virtual;

    { S is guaranteed (guaranteed by the user) to be correct html content,
      this is taken directly from parameters of @html tag.
      Override this function to decide what to put in output on such thing.

      Note that S is not processed in any way, even with ConvertString.
      So you're able to copy user's input inside @@html()
      verbatim to the output.

      The default implementation is this class simply discards it,
      i.e. returns always ''. Generators that know what to do with
      HTML can override this with simple "Result := S". }
    function HtmlString(const S: string): string; virtual;

    { This is equivalent of @link(HtmlString) for @@latex tag.

      The default implementation is this class simply discards it,
      i.e. returns always ''. Generators that know what to do with raw
      LaTeX markup can override this with simple "Result := S". }
    function LatexString(const S: string): string; virtual;

    { @abstract(This returns markup that forces line break in given
      output format (e.g. '<br>' in html or '\\' in LaTeX).)

      It is used on @br tag (but may also be used on other
      occasions in the future).

      In this class it returns '', because it's valid for
      an output generator to simply ignore @br tags if linebreaks
      can't be expressed in given output format. }
    function LineBreak: string; virtual;

    procedure WriteStartOfCode; virtual;

    procedure WriteEndOfCode; virtual;
  //<@groupend

    { This should return markup upon finding URL in description.
      E.g. HTML generator will want to wrap this in
      <a href="...">...</a>.

      Note that passed here URL is @italic(not) processed by @link(ConvertString)
      (because sometimes it could be undesirable).
      If you want you can process URL with ConvertString when
      overriding this method.

      Default implementation in this class simply returns ConvertString(URL).
      This is good if your documentation format does not support
      anything like URL links. }
    function URLLink(const URL: string): string; virtual;

    {@name is used to write the introduction and conclusion
     of the project.}
    procedure WriteExternal(const ExternalItem: TExternalItem;
      const Id: TTranslationID);

    { This is called from @link(WriteExternal) when
      ExternalItem.Title and ShortTitle are already set,
      message about generating appropriate item is printed etc.
      This should write ExternalItem, including
      ExternalItem.DetailedDescription,
      ExternalItem.Authors,
      ExternalItem.Created,
      ExternalItem.LastMod. }
    procedure WriteExternalCore(const ExternalItem: TExternalItem;
      const Id: TTranslationID); virtual; abstract;

    {@name writes a conclusion for the project.
     See @link(WriteExternal).}
    procedure WriteConclusion;

    {@name writes an introduction for the project.
     See @link(WriteExternal).}
    procedure WriteIntroduction;

  public
    destructor Destroy; override;

    { Expands description for each item in each unit of @link(Units).
      "Expands description" means that TTagManager.Execute is called,
      and item's RawDescription is transformed into DetailedDescription,
      interpreting @@-tags as appropriate for the selected document type. }
    procedure ExpandDescriptions; override; //<Could be implemented in the base class.

    { Write all documentation.

      This implementation only creates the GraphViz files, using WriteDocumentationGen.
      Must be overwritten for single or multiple output files, depending on the document type.
    }
    procedure WriteDocumentation; override; //virtual;
  //Write generator independent GraphViz files.
    procedure WriteDocumentationGen;
  end;

implementation

uses
  SysUtils,
  PasDoc_StreamUtils,
  PasDoc_Utils,
  PasDoc_Tokenizer;

{ TListItemData ------------------------------------------------------------- }

constructor TListItemData.Create(AItemLabel, AText: string; AIndex: Integer);
begin
  inherited Create;
  FItemLabel := AItemLabel;
  FText := AText;
  FIndex := AIndex;
end;

{ TListData ----------------------------------------------------------------- }

constructor TListData.Create(AOwnsObject: boolean);
begin
  inherited;
  FItemSpacing := lisParagraph;
  NextItemIndex := 1;
end;

{ TRowData ------------------------------------------------------------------- }

constructor TRowData.Create;
begin
  inherited;
  Cells := TStringList.Create;
end;

destructor TRowData.Destroy;
begin
  FreeAndNil(Cells);
  inherited;
end;

{ TTableData ----------------------------------------------------------------- }

procedure TTableData.CalculateCellCount;
var
  i: Integer;
  CC: Cardinal;
begin
  FMinCellCount := MaxInt;
  FMaxCellCount := 0;
  for i := 0 to Count - 1 do
  begin
    CC := TRowData(Items[i]).Cells.Count;
    if CC < FMinCellCount then FMinCellCount := CC;
    if CC > FMaxCellCount then FMaxCellCount := CC;
  end;
end;

{ ---------------------------------------------------------------------------- }
{ TDocGenerator                                                                }
{ ---------------------------------------------------------------------------- }

destructor TDocGenerator.Destroy;
begin
  ClearTags;
  FClassHierarchy.Free;
  FCurrentStream.Free;
  inherited;
end;

procedure TDocGenerator.SetUnits(U: TPasUnits);
begin
//clone the list, allow for later deletion of excluded units.
  //FUnits := TPasUnits.Create(False);
  Units.Assign(U);
end;


function  TDocGenerator.FindSections(item: TDescriptionItem): TSectionSet;
var
  i, j: integer;
  d: TDescriptionItem;
  SectionsAvailable: TSectionSet;
begin
  SectionsAvailable := [];
  for i := 0 to item.Count - 1 do begin
    d := item.ItemAt(i);
    Include(SectionsAvailable, d.ID);
    if d.id = trOverview then begin
      for j := 0 to d.Count - 1 do begin
        Include(SectionsAvailable, d.Items[j].ID);
      end;
    end;
  end;
  Result := SectionsAvailable;
end;

function TDocGenerator.HasDescription(const AItem: TPasItem): boolean;
begin
  Result := AItem.Count > 0;
end;

{ Returns TRUE if one of the subentries has a description
  otherwise returns FALSE
}
function TDocGenerator.HasDescriptions(c: TPasItems): boolean;
var j :integer;
    Item: TPasItem;
begin
  HasDescriptions := True; //assume
  for j := 0 to c.Count - 1 do begin
    Item := TPasItem(c.PasItemAt[j]);
    if HasDescription(Item) then
      exit;
  end;
  HasDescriptions := false;
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.CloseStream;
begin
  if Assigned(FCurrentStream) then begin
    FCurrentStream.Free;
    FCurrentStream := nil;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TDocGenerator.CreateStream(const AName: string;
  const AOverwrite: boolean): TCreateStreamResult;
begin
  CloseStream;
  DoMessage(4, pmtInformation, 'Creating output stream "' + AName + '".', []);
  Result := csError;
  FCurrentFileName := DestinationDirectory + AName;
  if FileExists(FCurrentFileName) and not AOverwrite then begin
    Result := csExisted;
  end else begin
    try
      FCurrentStream := TFileStream.Create(FCurrentFileName, fmCreate);
      Result := csCreated;
    except
    end;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.HandleLongCodeTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  if TagParameter = '' then
    exit;
  // Trim off "marker" characters at the beginning and end of TagParameter.
  // Then format pascal code.
  ReplaceStr := FormatPascalCode(
    Copy(TagParameter, 2, Length(TagParameter) - 2));
end;

procedure TDocGenerator.HandleHtmlTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := HtmlString(TagParameter);
end;

procedure TDocGenerator.HandleLatexTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := LatexString(TagParameter);
end;

procedure TDocGenerator.HandleNameTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := CodeString(ConvertString(FCurrentItem.Name));
end;

procedure TDocGenerator.HandleClassnameTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var ItemClassName: string;
begin
  { TODO: this should be moved to TPasItem handler, so that @classname
    is registered only for TPasItem (or, even better, for TPasCio
    and TPasItem with MyObject <> nil). }

  if fCurrentItem is TPasCio then
    ItemClassName := fCurrentItem.Name
  else if (FCurrentItem is TPasItem) //then begin
      and Assigned(TPasItem(fCurrentItem).MyObject) then
        ItemClassName := TPasItem(fCurrentItem).MyObject.Name
  else
    ItemClassName := '';

  if ItemClassName <> '' then
    ReplaceStr := CodeString(ConvertString(ItemClassName))
  else
    ThisTag.TagManager.DoMessage(1, pmtWarning, '@classname not available here', []);
end;

// handles @true, @false, @nil (Who uses these tags anyway?)
procedure TDocGenerator.HandleLiteralTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := CodeString(UpCase(ThisTag.Name[1]) + 
    Copy(ThisTag.Name, 2, MaxInt));
end;

procedure TDocGenerator.HandleInheritedClassTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);

  procedure InheritedClassCannotResolve(const Msg: string);
  begin
    ThisTag.TagManager.DoMessage(2, pmtWarning, 
      'Can''t resolve @inheritedClass: ' + Msg, []);
    ReplaceStr := CodeString(ConvertString(FCurrentItem.Name));
  end;

  procedure HandleFromClass(TheObject: TPasCio);
  begin
    if TheObject.FirstAncestorName = '' then
      InheritedClassCannotResolve('No ancestor class')
    else if TheObject.FirstAncestor = nil then
      ReplaceStr := CodeString(ConvertString(TheObject.FirstAncestorName))
    else
      ReplaceStr := MakeItemLink(TheObject.FirstAncestor,
        TheObject.FirstAncestorName, lcNormal);
  end;

begin
  if FCurrentItem is TPasCio then
    HandleFromClass(TPasCio(FCurrentItem))
  else if FCurrentItem is TPasItem then begin
    if Assigned(TPasItem(FCurrentItem).MyObject) then
      HandleFromClass(TPasItem(FCurrentItem).MyObject)
    else
      InheritedClassCannotResolve('This item is not a member of a class/interface/etc.');
  end else
    InheritedClassCannotResolve('You can''t use @inheritedClass here');
end;

procedure TDocGenerator.HandleInheritedTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);

  procedure InheritedCannotResolve(const Msg: string);
  begin
    ThisTag.TagManager.DoMessage(2, pmtWarning,
      'Can''t resolve @inherited: ' + Msg, []);
    ReplaceStr := CodeString(ConvertString(FCurrentItem.Name));
  end;

var
  TheObject: TPasCio;
  InheritedItem: TPasItem;
begin
  { TODO: this should be moved to TPasItem handler, so that @inherited
    is registered only for TPasItem (or, even better, for TPasCio
    and TPasItem with MyObject <> nil). }

  if FCurrentItem is TPasCio then begin
    TheObject := TPasCio(FCurrentItem);
    if TheObject.FirstAncestorName = '' then
      InheritedCannotResolve('No ancestor class')
    else if TheObject.FirstAncestor = nil then
      ReplaceStr := CodeString(ConvertString(TheObject.FirstAncestorName))
    else
      ReplaceStr := MakeItemLink(TheObject.FirstAncestor,
        TheObject.FirstAncestorName, lcNormal);
  end else if FCurrentItem is TPasItem then begin
    if Assigned(TPasItem(FCurrentItem).MyObject) then begin
      InheritedItem := TPasItem(FCurrentItem).MyObject.FindItemInAncestors(
        FCurrentItem.Name);
      if InheritedItem = nil then
        InheritedCannotResolve(Format('Member "%s" not found in ancestors',
          [FCurrentItem.Name]))
      else
        ReplaceStr := MakeItemLink(InheritedItem,
          InheritedItem.MyObject.Name + '.' + InheritedItem.Name, lcNormal);
    end else
      InheritedCannotResolve('This item is not a member of a class/interface/etc.');
  end else
    InheritedCannotResolve('You can''t use @inherited here');
end;

procedure TDocGenerator.HandleLinkTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var LinkTarget, LinkDisplay: string;
begin
  ExtractFirstWord(TagParameter, LinkTarget, LinkDisplay);
  ReplaceStr := SearchLink(LinkTarget, FCurrentItem, LinkDisplay, true);
end;

procedure TDocGenerator.HandleCodeTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := CodeString(TagParameter);
end;

procedure TDocGenerator.HandleBrTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := LineBreak;
end;

procedure TDocGenerator.HandleBoldTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := FormatBold(TagParameter);
end;

procedure TDocGenerator.HandleItalicTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := FormatItalic(TagParameter);
end;

procedure TDocGenerator.HandlePreformattedTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := FormatPreformatted(TagParameter);
end;

type
  { For @@orderedList, @@unorderedList and @@definitionList tags. }
  TListTag = class(TTag)
    function CreateOccurenceData: TObject; override;
  end;

function TListTag.CreateOccurenceData: TObject;
begin
  Result := TListData.Create(true);
end;

procedure TDocGenerator.HandleOrderedListTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  ListData: TListData;
begin
  ListData := ThisTagData as TListData;
  ListData.FListType := ltOrdered;
  ReplaceStr := FormatList(ListData);
end;

procedure TDocGenerator.HandleUnorderedListTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  ListData: TListData;
begin
  ListData := ThisTagData as TListData;
  ListData.FListType := ltUnordered;
  ReplaceStr := FormatList(ListData);
end;

procedure TDocGenerator.HandleDefinitionListTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  ListData: TListData;
begin
  ListData := ThisTagData as TListData;
  ListData.FListType := ltDefinition;
  
  if ListData.LastItemLabel <> '' then
  begin
    ListData.Add(TListItemData.Create(
      ListData.LastItemLabel, '', ListData.NextItemIndex));
      
    Inc(ListData.NextItemIndex);
    ListData.LastItemLabel := '';
  end;
  
  ReplaceStr := FormatList(ListData);
end;

procedure TDocGenerator.HandleItemTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  ListData: TListData;
begin
  ListData := EnclosingTagData as TListData;
    
  ListData.Add(TListItemData.Create(
    ListData.LastItemLabel, TagParameter, ListData.NextItemIndex));
    
  Inc(ListData.NextItemIndex);
  ListData.LastItemLabel := '';
  
  ReplaceStr := '';
end;

procedure TDocGenerator.HandleItemLabelTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  ListData: TListData;
begin
  ListData := EnclosingTagData as TListData;
  
  { If last tag was also @@itemLabel, not @@item, then make
    new item from ListData.LastItemLabel with empty Text. }
  if ListData.LastItemLabel <> '' then
  begin
    ListData.Add(TListItemData.Create(
      ListData.LastItemLabel, '', ListData.NextItemIndex));
    
    Inc(ListData.NextItemIndex);
  end;
  
  { This @@itemLabel is stored inside ListData.LastItemLabel.
    Will be added later to ListData.Items wrapped 
    inside some TListItemData. }
  ListData.LastItemLabel := TagParameter;
  
  ReplaceStr := '';
end;

procedure TDocGenerator.HandleItemSpacingTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  ListData: TListData;
  LTagParameter: string;
begin
  ListData := EnclosingTagData as TListData;

  LTagParameter := LowerCase(TagParameter);
  if LTagParameter = 'compact' then
    ListData.FItemSpacing := lisCompact else
  if LTagParameter = 'paragraph' then
    ListData.FItemSpacing := lisParagraph else
    ThisTag.TagManager.DoMessage(1, pmtWarning, 
      'Invalid parameter for @itemSpacing tag: "%s"', [TagParameter]);
      
  { @itemSpacing does not generate any output to ReplaceStr. 
    It only sets ListData.ItemSpacing }
  ReplaceStr := '';
end;

procedure TDocGenerator.HandleItemSetNumberTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  NewNextItemIndex: Integer;
begin
  ReplaceStr := '';
  
  try
    NewNextItemIndex := StrToInt(TagParameter);
    (EnclosingTagData as TListData).NextItemIndex := NewNextItemIndex;
  except
    on E: EConvertError do 
      ThisTag.TagManager.DoMessage(1, pmtWarning, 
        'Cannot convert parameter of @itemSetNumber tag ("%s") to a number: %s', 
        [TagParameter, E.Message]);
  end;
end;

type
  { For @@row and @@rowHead tags. }
  TRowTag = class(TTag)
    function CreateOccurenceData: TObject; override;
  end;

  TTableTag = class(TTag)
    function CreateOccurenceData: TObject; override;
  end;

function TRowTag.CreateOccurenceData: TObject;
begin
  Result := TRowData.Create;
end;

function TTableTag.CreateOccurenceData: TObject;
begin
  Result := TTableData.Create(true);
end;

procedure TDocGenerator.HandleTableTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
  
  procedure Error(const S: string);
  begin
    ThisTag.TagManager.DoMessage(1, pmtWarning, S, []);
    ReplaceStr := ConvertString(S);
  end;
  
var
  TableData: TTableData;
begin
  TableData := ThisTagData as TTableData;

  if TableData.Count = 0 then
  begin
    Error('Invalid @table: no rows');
    Exit;
  end;
  
  TableData.CalculateCellCount;
  
  if TableData.MinCellCount = 0 then
  begin
    Error('Invalid table @row: no cells');
    Exit;
  end;
  
  ReplaceStr := FormatTable(TableData);
end;

procedure TDocGenerator.HandleSomeRowTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := '';
  
  (ThisTagData as TRowData).Head := ThisTag = RowHeadTag;
  (EnclosingTagData as TTableData).Add(ThisTagData);
  
  { Since we just added ThisTagData to EnclosingTagData,
    it should no longer be freed by DestroyOccurenceData.
    It will be freed when EnclosingTagData will be freed. }
  ThisTagData := nil;
end;

procedure TDocGenerator.HandleCellTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := '';
  
  (EnclosingTagData as TRowData).Cells.Append(TagParameter);
end;

procedure TDocGenerator.HandleNoAutoLinkTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
begin
  ReplaceStr := ThisTag.TagManager.CoreExecute(TagParameter, false,
    ThisTag, ThisTagData);
end;

procedure TDocGenerator.HandleTableOfContentsTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  MaxLevel: Integer;
  AnchorIndex: Integer;
  ItemAnchors: TBaseItems;

  procedure CollectSections(MinLevel: Integer; lst: TDescriptionItem);
  var
    Anchor: TAnchorItem;
    SectionEntry: TStringPair;
  begin
    SectionEntry := nil;
    repeat
      if AnchorIndex = ItemAnchors.Count then
        Exit;
      Anchor := ItemAnchors[AnchorIndex] as TAnchorItem;
      if Anchor.SectionLevel = 0 then begin
        Inc(AnchorIndex);
      end else if Anchor.SectionLevel = MinLevel then begin
        Inc(AnchorIndex);
        SectionEntry := TDescriptionItem.Create(Anchor.Name, Anchor.SectionCaption, trNoTrans, dkItemList);
        CollectSections(MinLevel + 1, SectionEntry);
      end else if Anchor.SectionLevel > MinLevel then begin
        { This is for the case of malformed sections,
          i.e. user suddenly specified section with level
          greater than the "last section level + 1".
          In the future we may just give a warning to the user
          and refuse to work in such case ?
          For now, we just try to go on and produce something sensible. }
        SectionEntry := TDescriptionItem.Create('', '', trDummy, dkItemList);
        CollectSections(MinLevel + 1, SectionEntry);
      end else begin
        { So Anchor.SectionLevel < MinLevel,
          so we have to return from recursive call. }
        Exit;
      end;
      if SectionEntry <> nil then begin
        if MinLevel <= MaxLevel then
          lst.Add(SectionEntry)
        else
          SectionEntry.Free;
        SectionEntry := nil;
      end;
    until false;
  end;

  procedure FreeSectionsList(List: TStringPairVector);
  begin
    List.Free;
  end;

var
  TopLevelSections: TDescriptionItem;
begin //HandleTableOfContentsTag
  { calculate MaxLevel }
  if Trim(TagParameter) = '' then
    MaxLevel := MaxInt else
  try
    MaxLevel := StrToInt(TagParameter);
  except on E: EConvertError do
    begin
      ThisTag.TagManager.DoMessage(1, pmtWarning,
        'Invalid parameter of @tableOfContents tag: "%s". %s',
        [TagParameter, E.Message]);
      Exit;
    end;
  end;

  { calculate ItemAnchors }
  ItemAnchors := (FCurrentItem as TExternalItem).Anchors;

  { calculate TopLevelSections }
  AnchorIndex := 0;
  TopLevelSections := TDescriptionItem.Create('', '', trDummy, dkItemList);
  CollectSections(1, TopLevelSections);

  { now make use of TopLevelSections -- call FormatTableOfContents }
  ReplaceStr := FormatTableOfContents(TopLevelSections);

  { free TopLevelSections }
  TopLevelSections.Free;
end;

procedure TDocGenerator.DoMessageFromExpandDescription(
  const MessageType: TPasDocMessageType; const AMessage: string;
  const AVerbosity: Cardinal);
begin
  if Assigned(OnMessage) then
    OnMessage(MessageType, AMessage +
      ' (in description of "' + FCurrentItem.QualifiedName + '")', AVerbosity);
end;

procedure TDocGenerator.TryAutoLink(TagManager: TTagManager;
  const QualifiedIdentifier: TNameParts;
  out QualifiedIdentifierReplacement: string;
  var AutoLinked: boolean);
var
  FoundItem: TBaseItem;
  QualifiedIdentifierGlued: string;
begin
  QualifiedIdentifierGlued := GlueNameParts(QualifiedIdentifier);
  
  { first, check that we're not on AutoLinkExclude list }
  AutoLinked := AutoLinkExclude.IndexOf(QualifiedIdentifierGlued) = -1;
  
  if AutoLinked then
  begin
    FoundItem := FCurrentItem.FindName(QualifiedIdentifier);
    if FoundItem = nil then
      FoundItem := FindGlobal(QualifiedIdentifier);

    AutoLinked := (FoundItem <> nil) and FoundItem.AutoLinkHereAllowed;
    if AutoLinked then
    begin
      if FCurrentItem <> FoundItem then
        QualifiedIdentifierReplacement := MakeItemLink(FoundItem,
          QualifiedIdentifierGlued, lcNormal) else
        QualifiedIdentifierReplacement := 
          CodeString(ConvertString(QualifiedIdentifierGlued));
    end;
  end;
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.ClearTags;
begin
  FreeAndNil(FTagManager);
  //delete cache last!
  FreeAndNil(TagCache);
end;

procedure TDocGenerator.InitTagMgr;
begin
  if FTagManager = nil then
    FTagManager := TTagManager.Create;
//called before expanding all descriptions
  FTagManager.Abbreviations := Abbreviations;
  FTagManager.ConvertString := {$IFDEF FPC}@{$ENDIF} ConvertString;
  FTagManager.URLLink := {$IFDEF FPC}@{$ENDIF} URLLink;
  FTagManager.OnMessage := {$IFDEF FPC}@{$ENDIF} DoMessageFromExpandDescription;
  FTagManager.OnTryAutoLink := {$IFDEF FPC}@{$ENDIF} TryAutoLink;
  FTagManager.Paragraph := Paragraph;
  FTagManager.ShortDash := ShortDash;
  FTagManager.EnDash := EnDash;
  FTagManager.EmDash := EmDash;
end;

procedure TDocGenerator.InitTags(Item: TBaseItem);
begin
  FTagManager.Clear;
  AddTags;
  Item.RegisterTags(FTagManager);

//not yet cached
  if FCurrentItem is TExternalItem then begin
    TTopLevelTag.Create(FTagManager, 'section',
      {$IFDEF FPC}@{$ENDIF} PreHandleSectionTag,
      {$IFDEF FPC}@{$ENDIF} HandleSectionTag, [toParameterRequired]);
    TTopLevelTag.Create(FTagManager, 'anchor',
      {$IFDEF FPC}@{$ENDIF} PreHandleAnchorTag,
      {$IFDEF FPC}@{$ENDIF} HandleAnchorTag, [toParameterRequired]);
    TTopLevelTag.Create(FTagManager, 'tableofcontents',
      nil, {$IFDEF FPC}@{$ENDIF} HandleTableOfContentsTag,
      [toParameterRequired]);
  end;
end;


procedure TDocGenerator.AddTags;
var
  i: integer;
begin
  if TagCache = nil then begin
    { Tags without params }
    TTag.Create(FTagManager, 'classname',
      nil, {$IFDEF FPC}@{$ENDIF} HandleClassnameTag, []);
    TTag.Create(FTagManager, 'true',
      nil, {$IFDEF FPC}@{$ENDIF} HandleLiteralTag, []);
    TTag.Create(FTagManager, 'false',
      nil, {$IFDEF FPC}@{$ENDIF} HandleLiteralTag, []);
    TTag.Create(FTagManager, 'nil',
      nil, {$IFDEF FPC}@{$ENDIF} HandleLiteralTag, []);
    TTag.Create(FTagManager, 'inheritedclass',
      nil, {$IFDEF FPC}@{$ENDIF} HandleInheritedClassTag, []);
    TTag.Create(FTagManager, 'inherited',
      nil, {$IFDEF FPC}@{$ENDIF} HandleInheritedTag, []);
    TTag.Create(FTagManager, 'name',
      nil, {$IFDEF FPC}@{$ENDIF} HandleNameTag, []);
    TTag.Create(FTagManager, 'br',
      nil, {$IFDEF FPC}@{$ENDIF} HandleBrTag, []);

    { Tags with non-recursive params }
    TTag.Create(FTagManager, 'longcode',
      nil, {$IFDEF FPC}@{$ENDIF} HandleLongCodeTag,
      [toParameterRequired]);
    TTag.Create(FTagManager, 'html',
      nil, {$IFDEF FPC}@{$ENDIF} HandleHtmlTag,
      [toParameterRequired]);
    TTag.Create(FTagManager, 'latex',
      nil, {$IFDEF FPC}@{$ENDIF} HandleLatexTag,
      [toParameterRequired]);
    TTag.Create(FTagManager, 'link',
      nil, {$IFDEF FPC}@{$ENDIF} HandleLinkTag,
      [toParameterRequired]);
    TTag.Create(FTagManager, 'preformatted',
      nil, {$IFDEF FPC}@{$ENDIF} HandlePreformattedTag,
      [toParameterRequired]);
    TTag.Create(FTagManager, 'image',
      nil, {$IFDEF FPC}@{$ENDIF} HandleImageTag,
      [toParameterRequired]);
    TTag.Create(FTagManager, 'include',
      { @include tag works the same way in both expanding passes. }
      {$IFDEF FPC}@{$ENDIF} HandleIncludeTag,
      {$IFDEF FPC}@{$ENDIF} HandleIncludeTag,
      [toParameterRequired]);

    { Tags with recursive params }
    TTag.Create(FTagManager, 'code',
      nil, {$IFDEF FPC}@{$ENDIF} HandleCodeTag,
      [toParameterRequired, toRecursiveTags, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]);
    TTag.Create(FTagManager, 'bold',
      nil, {$IFDEF FPC}@{$ENDIF} HandleBoldTag,
      [toParameterRequired, toRecursiveTags, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]);
    TTag.Create(FTagManager, 'italic',
      nil, {$IFDEF FPC}@{$ENDIF} HandleItalicTag,
      [toParameterRequired, toRecursiveTags, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]);

    { Note that @@noAutoLink doesn't have toRecursiveTags flag specified.
      But it *does* recursively expand it's parameters -- it's handled
      by explicitly calling TagManager.Execute inside HandleNoAutoLinkTag. }
    TTag.Create(FTagManager, 'noautolink',
      nil, {$IFDEF FPC}@{$ENDIF} HandleNoAutoLinkTag,
      [toParameterRequired, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]);

    OrderedListTag := TListTag.Create(FTagManager, 'orderedlist',
      nil, {$IFDEF FPC}@{$ENDIF} HandleOrderedListTag,
      [toParameterRequired, toRecursiveTags]);
    UnorderedListTag := TListTag.Create(FTagManager, 'unorderedlist',
      nil, {$IFDEF FPC}@{$ENDIF} HandleUnorderedListTag,
      [toParameterRequired, toRecursiveTags]);
    DefinitionListTag := TListTag.Create(FTagManager, 'definitionlist',
      nil, {$IFDEF FPC}@{$ENDIF} HandleDefinitionListTag,
      [toParameterRequired, toRecursiveTags]);

    {ItemTag :=} TTag.Create(FTagManager, 'item',
      nil, {$IFDEF FPC}@{$ENDIF} HandleItemTag,
      [toParameterRequired, toRecursiveTags, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]).OnAllowedInside := {$IFDEF FPC}@{$ENDIF} TagAllowedInsideLists;

    {ItemLabelTag :=} TTag.Create(FTagManager, 'itemlabel',
      nil, {$IFDEF FPC}@{$ENDIF} HandleItemLabelTag,
      [toParameterRequired, toRecursiveTags, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]).OnAllowedInside :=
      {$IFDEF FPC}@{$ENDIF} ItemLabelTagAllowedInside;

    {ItemSpacingTag :=} TTag.Create(FTagManager, 'itemspacing',
      nil, {$IFDEF FPC}@{$ENDIF} HandleItemSpacingTag,
      [toParameterRequired]).OnAllowedInside :=
      {$IFDEF FPC}@{$ENDIF} TagAllowedInsideLists;

    {ItemSetNumberTag :=} TTag.Create(FTagManager, 'itemsetnumber',
      nil, {$IFDEF FPC}@{$ENDIF} HandleItemSetNumberTag,
      [toParameterRequired, toAllowNormalTextInside]).OnAllowedInside :=
      {$IFDEF FPC}@{$ENDIF} TagAllowedInsideLists;

    TableTag := TTableTag.Create(FTagManager, 'table',
      nil, {$IFDEF FPC}@{$ENDIF} HandleTableTag,
      [toParameterRequired, toRecursiveTags]);

    RowTag := TRowTag.Create(FTagManager, 'row',
      nil, {$IFDEF FPC}@{$ENDIF} HandleSomeRowTag,
      [toParameterRequired, toRecursiveTags]);
    RowTag.OnAllowedInside := {$IFDEF FPC}@{$ENDIF} TagAllowedInsideTable;

    RowHeadTag := TRowTag.Create(FTagManager, 'rowhead',
      nil, {$IFDEF FPC}@{$ENDIF} HandleSomeRowTag,
      [toParameterRequired, toRecursiveTags]);
    RowHeadTag.OnAllowedInside := {$IFDEF FPC}@{$ENDIF} TagAllowedInsideTable;

    {CellTag :=} TTag.Create(FTagManager, 'cell',
      nil, {$IFDEF FPC}@{$ENDIF} HandleCellTag,
      [toParameterRequired, toRecursiveTags, toAllowOtherTagsInsideByDefault,
       toAllowNormalTextInside]).OnAllowedInside := {$IFDEF FPC}@{$ENDIF} TagAllowedInsideRows;

  //now cache all tags
    TagCache := TObjectVector.Create(True);
    for i := 0 to FTagManager.Count - 1 do begin
      TTag(FTagManager.Items[i]).Cached := True;
      TagCache.Add(FTagManager.Items[i]);
    end;
  end else begin
    //TagManager.Clear; - item tags already added!
    for i := 0 to TagCache.Count - 1 do
      FTagManager.Add(TagCache.Items[i]);
  end;
end;

procedure TDocGenerator.ExpandDescriptions;

  (*Takes description D of the Item, expands links (using Item),
    converts output-specific characters.

    Note that you can't process with this function more than once
    the same Description (i.e. like
    @longcode(#
      { BAD EXAMPLE }
      Description := ExpandDescription(Item, Description);
      Description := ExpandDescription(Item, Description);
    #)) because output of this function is already something
    ready to be included in final doc output, it shouldn't be
    processed once more, moreover this function initializes
    some properties of Item to make them also in the
    "already-processed" form (ready to be included in final docs).

    Meaning of WantFirstSentenceEnd and FirstSentenceEnd:
    see @link(TTagManager.Execute). *)
  function ExpandDescription(PreExpand: boolean; Item: TBaseItem;
    const Description: string;
    WantFirstSentenceEnd: boolean;
    out FirstSentenceEnd: Integer): string; overload;
  begin
    // make it available to the handlers
    FCurrentItem := Item;

    FTagManager.PreExecute := PreExpand;

    Result := FTagManager.Execute(Description, AutoLink,
      WantFirstSentenceEnd, FirstSentenceEnd);
    FTagManager.Clear;
  end;

  { Same thing as ExpandDescription(PreExpand, Item, Description, false, Dummy) }
  function ExpandDescription(PreExpand: boolean; Item: TBaseItem;
    const Description: string): string; overload;
  var Dummy: Integer;
  begin
    Result := ExpandDescription(PreExpand, Item, Description, false, Dummy);
  end;

  procedure ExpandCollection(PreExpand: boolean; c: TPasItems); forward;

  { expands RawDescription of Item }
  procedure ExpandPasItem(PreExpand: boolean; Item: TPasItem);
  var
    FirstSentenceEnd: Integer;
    Expanded: string;
    scoped: TPasScope absolute Item; //has overview
    mbrs: TPasItems;
  begin
    if (Item = nil) or Item.ToBeExcluded then
      Exit; //exclude items marked for exclusion in PreExpand

    { Note: don't just Trim or TrimCompress here resulting
      Item.DetailedDescription (because whitespaces,
      including leading and trailing, may be important for final doc format;
      moreover, you would break the value of FirstSentenceEnd by such thing). }
    InitTags(Item);
    Expanded := ExpandDescription(PreExpand,
      Item, Trim(Item.RawDescription), true, FirstSentenceEnd);
    if not PreExpand then
      Item.DetailedDescription := Expanded;

    if item is TPasScope then begin
    //expand the Members list. No groups or excluded items yet!
      mbrs := scoped.Members;
      ExpandCollection(PreExpand, mbrs);
    end;
  end;

  procedure ExpandExternalItem(PreExpand: boolean; Item: TExternalItem);
  var
    Expanded: string;
  begin
    Expanded := ExpandDescription(PreExpand, Item, Trim(Item.RawDescription));
    if not PreExpand then
      Item.DetailedDescription := Expanded;
  end;

  { for all items in collection C, expands descriptions }
  procedure ExpandCollection(PreExpand: boolean; c: TPasItems);
  var
    i: Integer;
  begin
    if c = nil then Exit;
    for i := 0 to c.Count - 1 do
      ExpandPasItem(PreExpand, c.PasItemAt[i]);
  end;

  procedure ExpandEverything(PreExpand: boolean);
  var
    i: Integer;
    U: TPasUnit;
  begin
    if Introduction <> nil then
      ExpandExternalItem(PreExpand, Introduction);
    if Conclusion <> nil then
      ExpandExternalItem(PreExpand, Conclusion);

    for i := 0 to Units.Count - 1 do begin
      U := Units.UnitAt[i];
      ExpandPasItem(PreExpand, U);
    end;
  end;

begin //ExpandDescriptions
  InitTagMgr;
  DoMessage(2, pmtInformation, 'Expanding descriptions (pass 1) ...', []);
  ExpandEverything(true);
  DoMessage(2, pmtInformation, 'Expanding descriptions (pass 2) ...', []);
  ExpandEverything(false);
  DoMessage(2, pmtInformation, '... Descriptions expanded', []);
end;

{ ---------------------------------------------------------------------------- }

function TDocGenerator.ExtractEmailAddress(s: string; out S1, S2,
  EmailAddress: string): Boolean;
const
  ALLOWED_CHARS = ['a'..'z', 'A'..'Z', '-', '.', '_', '0'..'9'];
  Letters = ['a'..'z', 'A'..'Z'];
var
  atPos: Integer;
  i: Integer;
begin
  Result := False;
  if (Length(s) < 6) { minimum length of email address: a@b.cd } then Exit;
  atPos := Pos('@', s);
  if (atPos < 2) or (atPos > Length(s) - 3) then Exit;
  { assemble address left of @ }
  i := atPos - 1;
  while (i >= 1) and (s[i] in ALLOWED_CHARS) do
    Dec(i);
  EmailAddress := System.Copy(s, i + 1, atPos - i - 1) + '@';
  S1 := '';
  if (i > 1) then S1 := System.Copy(s, 1, i);
  { assemble address right of @ }
  i := atPos + 1;
  while (i <= Length(s)) and (s[i] in ALLOWED_CHARS) do
    Inc(i);
  EmailAddress := EmailAddress + System.Copy(s, atPos + 1, i - atPos - 1);
  if (Length(EmailAddress) < 6) or
    (not (EmailAddress[Length(EmailAddress)] in Letters)) or
  (not (EmailAddress[Length(EmailAddress) - 1] in Letters)) then Exit;
  S2 := '';
  if (i <= Length(s)) then S2 := System.Copy(s, i, Length(s) - i + 1);
  Result := True;
end;

function TDocGenerator.ExtractWebAddress(s: string; out S1, S2,
  WebAddress: string): Boolean;
const
  ALLOWED_CHARS = ['a'..'z', 'A'..'Z', '-', '.', '_', '0'..'9'];
var
  p: integer;
begin
  Result := false;
  p := Pos('http://', s);
  if p > 0 then begin
    { if it starts with "http://" it is at least meant to be a web address }
    S1 := Copy(s, 1, p - 1);
    WebAddress := Copy(s, p + 7, 255);
    p := 1;
    while (p < Length(WebAddress)) and (WebAddress[p] in ALLOWED_CHARS) do
      Inc(p);
    S2 := Copy(WebAddress, p, 255);
    WebAddress := Copy(WebAddress, 1, p - 1);
    Result := true;
  end else begin
    p := Pos('www.', s);
    if p = 0 then
      exit;
    { if it starts with "www.", its most likely a web address, we could probably
      add more checks here (like: does it contain an additional dot for the TLD?) }
    S1 := Copy(s, 1, p - 1);
    WebAddress := Copy(s, p, 255);
    p := 1;
    while (p < Length(WebAddress)) and (WebAddress[p] in ALLOWED_CHARS) do
      Inc(p);
    S2 := Copy(WebAddress, p, 255);
    WebAddress := Copy(WebAddress, 1, p - 1);
    Result := true;
  end;
end;

{ ---------------------------------------------------------------------------- }

function TDocGenerator.GetClassDirectiveName(Directive: TClassDirective): string;
begin
  case Directive of
    CT_ABSTRACT:  result := ' abstract';
    CT_SEALED:    result := ' sealed';
  else
    result := '';
  end;
end;

function TDocGenerator.GetCIOTypeName(MyType: TCIOType): string;
begin
{ TODO : split into token->tid, tid->name }
  case MyType of
  KEY_RECORD: Result := Language.Translation[trRecord];
  KEY_CLASS: Result := Language.Translation[trClass];
  KEY_DISPINTERFACE: Result := Language.Translation[trDispInterface];
  KEY_INTERFACE: Result := Language.Translation[trInterface];
  KEY_OBJECT: Result := Language.Translation[trObject];
  else      Result := '';
  end;
end;

{ ---------------------------------------------------------------------------- }

function TDocGenerator.SearchItem(s: string; const Item: TBaseItem;
  WarningIfNotSplittable: boolean): TBaseItem;
var
  NameParts: TNameParts;
begin
  if not SplitNameParts(s, NameParts) then
  begin
    if WarningIfNotSplittable then
      DoMessage(2, pmtWarning, 'The link "' + s + '" is invalid', []);
    Result := nil;
    Exit;
  end;

  { first try to find link starting at Item }
  if Assigned(Item) then
    Result := Item.FindName(NameParts)
  else
    Result := nil;

  if not Assigned(Result) then
    Result := FindGlobal(NameParts);
end;

{ ---------------------------------------------------------------------------- }

function TDocGenerator.SearchLink(s: string; const Item: TBaseItem;
  const LinkDisplay: string;
  const WarningIfLinkNotFound: boolean;
  out FoundItem: TBaseItem): string;
var
  NameParts: TNameParts;
begin
  FoundItem := nil;

  if (not SplitNameParts(s, NameParts)) then begin
    DoMessage(2, pmtWarning, 'Invalid Link "' + s + '" (' + Item.QualifiedName + ')', []);
    Result := 'UNKNOWN';
    Exit;
  end;

  { first try to find link starting at Item }
  if Assigned(Item) then begin
    FoundItem := Item.FindName(NameParts);
  end;

  { Find Global }
  if FoundItem = nil then
    FoundItem := FindGlobal(NameParts);

  if Assigned(FoundItem) then begin
    if LinkDisplay <> '' then
      Result := MakeItemLink(FoundItem, LinkDisplay, lcNormal)
    else begin
      case LinkLook of
      llDefault:
        Result := MakeItemLink(FoundItem, S, lcNormal);
      llStripped:
        Result := MakeItemLink(FoundItem, FoundItem.Name, lcNormal);
      llFull:
        begin
          Result := MakeItemLink(FoundItem, FoundItem.Name, lcNormal);

          if Length(NameParts) = 3 then begin
            SetLength(NameParts, 2);
            FoundItem := FindGlobal(NameParts);
            Result := MakeItemLink(FoundItem, FoundItem.Name, lcNormal) +
              '.' + Result;
          end;

          if Length(NameParts) = 2 then begin
            SetLength(NameParts, 1);
            FoundItem := FindGlobal(NameParts);
            Result := MakeItemLink(FoundItem, FoundItem.Name, lcNormal) +
              '.' + Result;
          end;
        end;
        // else Assert(false, 'LinkLook = ??');
      end;
    end;
  end else if WarningIfLinkNotFound then begin
    DoMessage(1, pmtWarning, 'Could not resolve link "%s" (from description of "%s")',
      [S, Item.QualifiedName]);
    Result := CodeString(ConvertString(S));
  end else
    Result := '';
end;

function TDocGenerator.SearchLink(s: string; const Item: TBaseItem;
  const LinkDisplay: string;
  const WarningIfLinkNotFound: boolean): string;
var
  Dummy: TBaseItem;
begin
  Result := SearchLink(S, Item, LinkDisplay, WarningIfLinkNotFound, Dummy);
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.WriteConverted(const s: string; Newline: boolean);
begin
  WriteDirect(ConvertString(s), Newline);
end;

procedure TDocGenerator.WriteConverted(const s: string);
begin
  WriteDirect(ConvertString(s));
end;

procedure TDocGenerator.WriteConvertedLine(const s: string);
begin
  WriteDirectLine(ConvertString(s));
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.WriteDirect(const t: string; Newline: boolean);
begin
  if NewLine then
    WriteDirectLine(T)
  else
    WriteDirect(T);
end;

procedure TDocGenerator.WriteDirect(const t: string);
begin
  StreamWriteString(CurrentStream, t);
end;

procedure TDocGenerator.WriteDirectLine(const t: string);
begin
  StreamWriteLine(CurrentStream, t);
end;

{ ---------------------------------------------------------------------------- }

{$IFDEF detailed}
procedure TDocGenerator.WriteAllSections(HL: integer;
  Items: TDescriptionItem; PasItem: TPasItem);
var
  d: TDescriptionItem;
  i: integer;
begin
  if IsEmpty(Items) then exit;

  for i := 0 to Items.Count - 1 do begin
    d := Items.ItemAt(i);
    WriteDescriptionItem(HL, d, PasItem);
  end;
end;

procedure TDocGenerator.WriteDescriptionItem(HL: integer;
  AItem: TDescriptionItem; PasItem: TPasItem);
var
  i: integer;
  item: TDescriptionItem;
begin
(* Fork into appropriate methods, depending on item kind (TTranslationID).
*)
  inc(HL);
  case AItem.ID of
  trUnit: //when item and unit reside in different files
    WriteUnitRef(HL, AItem);
  trUses: //units only
    if WriteUsesClause then
      WriteUnitUses(HL, AItem, PasItem);
  trDeclaration:  //item declaration
    WriteDeclaration(HL, AItem, PasItem);
  trDescription:  //abstract+detailed
    WriteDescription(HL, AItem, PasItem); //?
    //IS description, but only containing abstract+detailed description
  trHierarchy:  //classes only
    WriteHierarchy(HL, AItem, PasItem);
  trOverview: //Overview and Details tables
    WriteOverview(HL, AItem, PasItem.PasScope);
  trExceptionsRaised:
    WriteRaises(HL, AItem, PasItem);
  trParameters:
    WriteParams(HL, AItem, PasItem);
  trReturns:
    WriteReturnDesc(HL, AItem);
  trValues:  //ignore top level list, containing member groups.
    for i := 0 to AItem.Count - 1 do begin
      item := AItem.ItemAt(i); //expect: trValues, anonymous or named
      WriteValueList(HL, item);
    end;
  trAuthors:
    WriteAuthors(HL, AItem);
  trCreated, trLastModified:
    WriteDate(HL, AItem);
  trSeeAlso:
    WriteSeeAlso(HL, AItem, PasItem.PasScope);
  else  //case, should never be reached!
    WriteOther(HL, AItem, PasItem);
  end;
end;

procedure TDocGenerator.WriteAuthors(HL: integer; Items: TDescriptionItem);
begin
  WriteOther(HL, Items, nil);
end;

procedure TDocGenerator.WriteDate(HL: integer; AItem: TDescriptionItem);
begin
  WriteOther(HL, AItem, nil);
end;

procedure TDocGenerator.WriteDeclaration(HL: integer; AItem: TDescriptionItem; PasItem: TPasItem);
begin
  WriteOther(HL, AItem, PasItem);
end;

procedure TDocGenerator.WriteDescription(HL: integer; AItem: TDescriptionItem; PasItem: TPasItem);
begin
  WriteOther(HL, AItem, PasItem);
end;

procedure TDocGenerator.WriteHierarchy(HL: integer;
  Items: TDescriptionItem; AScope: TPasItem);
begin
  WriteOther(HL, Items, AScope);
end;

procedure TDocGenerator.WriteOverview(HL: integer; AList: TDescriptionItem;
  AScope: TPasScope);
begin
  WriteOther(HL, AList, AScope);
end;

procedure TDocGenerator.WriteParams(HL: integer; AItem: TDescriptionItem;
  AScope: TPasItem);
begin
  WriteOther(HL, AItem, AScope);
end;

procedure TDocGenerator.WriteRaises(HL: integer; AItem: TDescriptionItem;
  AScope: TPasItem);
begin
  WriteOther(HL, AItem, AScope);
end;

procedure TDocGenerator.WriteReturnDesc(HL: integer;
  AItem: TDescriptionItem);
begin
  WriteOther(HL, AItem, nil);
end;

procedure TDocGenerator.WriteUnitRef(HL: integer; AItem: TDescriptionItem);
begin
  WriteOther(HL, AItem, nil);
end;

procedure TDocGenerator.WriteUnitUses(HL: integer; AItem: TDescriptionItem;
  AScope: TPasItem);
begin
  WriteOther(HL, AItem, AScope);
end;

procedure TDocGenerator.WriteValueList(HL: integer;
  AItem: TDescriptionItem);
begin
  WriteOther(HL, AItem, nil);
end;

procedure TDocGenerator.WriteOther(HL: integer; AItem: TDescriptionItem;
  PasItem: TPasItem);
begin
//default output: must be overridden!
  DoMessage(1, pmtWarning, 'Unhandled description: %s: %s',
    [Translation(AItem.ID, lgDefault), AItem.Name]);
end;

//--------------------------------------------------------------------

procedure TDocGenerator.WriteItemFooter(HL: integer; AItem: TPasItem);
begin
  //nop, here
end;

procedure TDocGenerator.WriteItemHeader(HL: integer; AItem: TPasItem);
begin
  //nop, here
end;

procedure TDocGenerator.WriteItem(HL: integer; AItem: TDescriptionItem;
      PasItem: TPasScope);
var
  i: integer;
  d: TDescriptionItem;
begin
  WriteItemHeader(HL, PasItem);

  for i := 0 to AItem.Count - 1 do begin
    d := AItem.ItemAt(i);
    WriteDescriptionItem(HL, d, PasItem);
  end;

  WriteItemFooter(HL, PasItem);
end;

procedure TDocGenerator.WriteUnits(const HL: integer);
var
  i: Integer;
  U: TPasUnit;
begin
  if IsEmpty(Units) then Exit;
  for i := 0 to Units.Count - 1 do begin
    U := Units.UnitAt[i];
    WriteItem(HL, U, U);
  end;
end;
{$ELSE}

procedure TDocGenerator.WriteUnits(const HL: integer);
var
  i: Integer;
  U: TPasUnit;
begin
  if IsEmpty(Units) then Exit;
  for i := 0 to Units.Count - 1 do begin
    U := Units.UnitAt[i];
    WriteUnit(HL, U);
  end;
end;
{$ENDIF}

procedure TDocGenerator.WriteDocumentation;
begin
(* All generators must iterate over the units, and pick the information
  to present in the desired order.

  This method is not really inheritable, call WriteDocumentationGen instead.
  More general methods for frequent tasks should be added.
*)
  WriteDocumentationGen;
end;

procedure TDocGenerator.WriteDocumentationGen;
begin
//Write generator independent GraphViz files.
  if OutputGraphVizUses then WriteGVUses;
  if OutputGraphVizClassHierarchy then WriteGVClasses;
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.DoError(const AMessage: string; const AArguments:
  array of const; const AExitCode: Word);
begin
  raise EPasDoc.Create(AMessage, AArguments, AExitCode);
end;

{ ---------------------------------------------------------------------------- }

procedure TDocGenerator.DoMessage(const AVerbosity: Cardinal; const
  MessageType: TPasDocMessageType; const AMessage: string; const AArguments: array of
  const);
begin
  if Assigned(OnMessage) then begin
    OnMessage(MessageType, Format(AMessage, AArguments), AVerbosity);
  end;
end;


procedure TDocGenerator.CreateClassHierarchy;

  function AddBranch(c: TPasCio): TDescriptionItem;
  var
    a: TPasCio;
    parent: TDescriptionItem;
  begin
    parent := c.FirstAncestorItem;
    a := c.FirstAncestor; //the base class
    if parent = nil then begin //top level class
      parent := FClassHierarchy;
    end else if a = nil then begin //ends in non-CIO
      parent := FClassHierarchy.AddNew(c.ID, dkUniqueString, parent.Name);
    end else begin
      parent := AddBranch(a);
    end;
    Result := parent.AddNew(c.ID, dkDelegate, c.Name);
    Result.PasItem := c;
  end;

var
  iu, ic: integer;
  u: TPasUnit;
  c: TPasCio;
begin
  FClassHierarchy.Free;
  FClassHierarchy := TDescriptionItem.Create('', '', trClassHierarchy, dkItemList);
  for iu := 0 to Units.Count - 1 do begin
    u := Units.UnitAt[iu];
    for ic := 0 to u.CIOs.Count - 1 do begin
      c := u.CIOs.PasItemAt[ic] as TPasCio;

      if c.MyType in CioClassTypes then //exclude records from class hierarchy
        AddBranch(c); //ignore result
    end;
  end;
end;

procedure TDocGenerator.WriteEndOfCode;
begin
// nothing - for some output this is irrelevant
end;

procedure TDocGenerator.WriteStartOfCode;
begin
// nothing - for some output this is irrelevant
end;

{$IFDEF old}
procedure TDocGenerator.SetLanguage(const Value: TLanguageID);
begin
  FLanguage.Language := Value;
end;

procedure TDocGenerator.SetDestDir(const Value: string);
begin
  if Value <> '' then begin
    FDestDir := IncludeTrailingPathDelimiter(Value);
  end else begin
    FDestDir := '';
  end;
end;

function TDocGenerator.GetLanguage: TLanguageID;
begin
  Result := FLanguage.Language;
end;
{$ELSE}
{$ENDIF}

procedure TDocGenerator.WriteGVClasses;
var
  OverviewFileName: string;

  procedure WriteBranch(lst: TDescriptionItem);
  var
    ic: integer;
    LNode: TDescriptionItem;
    //item: TPasCio;
    pname: string;
  begin
    pname := lst.Name;
    for ic := 0 to lst.Count - 1 do begin
      LNode := lst.ItemAt(ic);
      //if Assigned(parent) then
      if pname <> '' then
        WriteDirectLine('  ' + LNode.Name + ' -> ' + pname);
      if LNode.PasItem is TPasCio then
        WriteDirectLine('  ' + LNode.Name +
          ' [href="' + TPasCio(LNode.PasItem).OutputFileName + '"]');
    end;
  end;

begin
  CreateClassHierarchy;
//traverse tree
  if not IsEmpty(FClassHierarchy) then begin
    OverviewFileName := OverviewFilesInfo[ofGraphVizClasses].BaseFileName  + '.dot';
    if CreateStream(OverviewFileName, True) = csError then begin
      DoMessage(1, pmtError, 'Could not create output file "%s".',
        [OverviewFileName]);
      Exit;
    end;

    WriteDirect('DiGraph Classes {', true);
    WriteBranch(FClassHierarchy);

  //finally
    WriteDirect('}', true);
    CloseStream;
  end;
end;

procedure TDocGenerator.WriteGVUses;
var
  i, j: Integer;
  U: TPasUnit;
  OverviewFileName: string;
begin
  if not IsEmpty(Units) then begin
    OverviewFileName := OverviewFilesInfo[ofGraphVizUses].BaseFileName + '.dot';
    if CreateStream(OverviewFileName, True) = csError then begin
      DoMessage(1, pmtError, 'Could not create output file "%s".',
        [OverviewFileName]);
      Exit;
    end;

    WriteDirect('DiGraph Uses {', true);
    for i := 0 to Units.Count-1 do begin
      U := TPasUnit(Units.PasItemAt[i]);
      if not IsEmpty(U.UsesUnits) then begin
        for j := 0 to U.UsesUnits.Count-1 do begin
          WriteDirectLine('  "' + U.Name + '" -> "' + U.UsesUnits.Items[j].Name + '"');
        end;
      end;

      WriteDirectLine('  "' + U.Name + '" [href="' + U.OutputFileName + '"]');
    end;
    WriteDirect('}', true);
    CloseStream;
  end;
end;

procedure TDocGenerator.CheckString(const AString: string;
  const AErrors: TObjectVector);
var i: Integer;
begin
  if CheckSpelling and (FAspellProcess <> nil) then
  begin
    FAspellProcess.CheckString(AString, AErrors);
    for i := 0 to AErrors.Count - 1 do
      DoMessage(2, pmtWarning, 'Word misspelled "%s"',
        [TSpellingError(AErrors[i]).Word]);
  end else
    AErrors.Clear;
end;

procedure TDocGenerator.EndSpellChecking;
begin
  { If CheckSpelling was false or StartSpellChecking failed then
    FAspellPipe will be nil, so it's safe to just always call FreeAndNil here. }
  FreeAndNil(FAspellProcess);
end;

procedure TDocGenerator.StartSpellChecking(const AMode: string);
var
  WordsToIgnore: TStringList;

  procedure AddSubItems(Items: TBaseItems);
  var
    SubItem: TBaseItem;
    Index: integer;
    AName: string;
    NewName: string;
  begin
    for Index := 0 to Items.Count -1 do begin
      SubItem := Items[Index] as TBaseItem;
      AName := Trim(SCharsReplace(SubItem.Name, ['0'..'9', '_'], ' '));
      if AName = SubItem.Name then begin
        if (SubItem.Name <> '') then begin
          WordsToIgnore.Add(SubItem.Name);
        end;
      end else begin
        While AName <> '' do begin
          NewName := ExtractFirstWord(AName);
          WordsToIgnore.Add(NewName);
        end;
      end;
      if SubItem is TExternalItem then begin
        AddSubItems(TExternalItem(SubItem).Anchors);
      end else if SubItem is TPasScope then begin
        AddSubItems(TPasScope(SubItem).Members);
      end;
    end;
  end;

begin
  { Make sure that previous aspell process is closed }
  FreeAndNil(FAspellProcess);

  if CheckSpelling then
  begin
    try
      FAspellProcess := TAspellProcess.Create(AMode, AspellLanguage);
    except
      on E: Exception do
      begin
        DoMessage(1, pmtWarning, 'Executing aspell failed, ' +
          'disabling spell checking: "%s"', [E.Message]);
        Exit;
      end;
    end;

    FAspellProcess.OnMessage := OnMessage;

    WordsToIgnore := TStringList.Create;
    try
      WordsToIgnore.Sorted := True;
      WordsToIgnore.Duplicates := dupIgnore;
      WordsToIgnore.AddStrings(SpellCheckIgnoreWords);

      if Introduction <> nil then
      begin
        WordsToIgnore.Add(Introduction.Name);
        AddSubItems(Introduction.Anchors);
      end;
      if Conclusion <> nil then
      begin
        WordsToIgnore.Add(Conclusion.Name);
        AddSubItems(Conclusion.Anchors);
      end;
      AddSubItems(Units);
      FAspellProcess.SetIgnoreWords(WordsToIgnore);
    finally
      WordsToIgnore.Free;
    end;
  end;
end;

{$IFDEF old}
procedure TDocGenerator.SetSpellCheckIgnoreWords(Value: TStringList);
begin
  SpellCheckIgnoreWords.Assign(Value);
end;
{$ELSE}
{$ENDIF}

function TDocGenerator.FormatPascalCode(const Line: string): string;

  { Calls FormatKeyWord or FormatNormalCode, depending on whether
    AString is keyword. }
  function FormatCode(const AString: string): string;
  begin
    if (KeyWordByName(AString) <> KEY_INVALIDKEYWORD) or
       (StandardDirectiveByName(AString) <> SD_INVALIDSTANDARDDIRECTIVE) then
      Result := FormatKeyWord(AString) else
      Result := FormatNormalCode(AString);
  end;

type
  TCodeType = (ctWhiteSpace, ctString, ctCode, ctEndString, ctChar,
    ctParenComment, ctBracketComment, ctSlashComment, ctCompilerComment,
    ctEndComment, ctHex, ctEndHex, ctNumeric, ctEndNumeric);
var
  CharIndex: integer;
  CodeType: TCodeType;
  CommentBegining: integer;
  StringBeginning: integer;
  CodeBeginning: integer;
  HexBeginning: Integer;
  NumBeginning: Integer;
  EndOfCode: boolean;
  WhiteSpaceBeginning: integer;
  NumberSubBlock: String;
  NumberRange: Integer;
const
  Separators = [' ', ',', '(', ')', #9, #10, #13, ';', '[', ']', '{', '}',
    '''', ':', '<', '>', '=', '+', '-', '*', '/', '@', '.'];
  LineEnd = [#10, #13];
  AlphaNumeric = ['0'..'9', 'a'..'z', 'A'..'Z', '_'];
  Numeric = ['0'..'9','.'];
  Hexadec = ['0'..'9', 'a'..'f', 'A'..'F', '$'];

  function TestCommentStart: boolean;
  begin
    result := False;
    if Line[CharIndex] = '(' then begin
      if (CharIndex < Length(Line)) and (Line[CharIndex + 1] = '*') then begin
        CodeType := ctParenComment;
        result := True;
      end
    end else if Line[CharIndex] = '{' then begin
      if (CharIndex < Length(Line)) and (Line[CharIndex + 1] = '$') then begin
        CodeType := ctCompilerComment;
      end else begin
        CodeType := ctBracketComment;
      end;
      result := True;
    end else if Line[CharIndex] = '/' then begin
      if (CharIndex < Length(Line)) and (Line[CharIndex + 1] = '/') then begin
        CodeType := ctSlashComment;
        result := True;
      end
    end;
    if result then begin
      CommentBegining := CharIndex;
    end;
  end;

  function TestStringBeginning: boolean;
  begin
    result := False;
    if Line[CharIndex] = '''' then begin
      if CodeType <> ctChar then begin
        StringBeginning := CharIndex;
      end;
      CodeType := ctString;
      result := True;
    end
  end;

begin
  CommentBegining := 1;
  StringBeginning := 1;
  HexBeginning    := 1;
  NumBeginning    := 1;
  result := '';
  CodeType := ctWhiteSpace;
  WhiteSpaceBeginning := 1;
  CodeBeginning := 1;
  for CharIndex := 1 to Length(Line) do
  begin
    case CodeType of
      ctWhiteSpace:
        begin
          EndOfCode := False;
          if TestStringBeginning then begin
            EndOfCode := True;
          end else if Line[CharIndex] = '#' then begin
            StringBeginning := CharIndex;
            CodeType := ctChar;
            EndOfCode := True;
          end else if TestCommentStart then begin
            EndOfCode := True;
          end else if Line[CharIndex] = '$' Then begin
            CodeType := ctHex;
            HexBeginning := CharIndex;
            EndOfCode := True;
          end else if Line[CharIndex] in Numeric then begin
            CodeType := ctNumeric;
            NumBeginning := CharIndex;
            EndOfCode := True;
          end else if Line[CharIndex] in AlphaNumeric then begin
            CodeType := ctCode;
            CodeBeginning := CharIndex;
            EndOfCode := True;
          end;
          if EndOfCode then begin
            result := result + ConvertString(Copy(Line, WhiteSpaceBeginning,
              CharIndex - WhiteSpaceBeginning));
          end;
        end;
      ctString:
        begin
          if Line[CharIndex] = '''' then begin
            if (CharIndex = Length(Line)) or (Line[CharIndex + 1] <> '''') then begin
              CodeType := ctEndString;
              result := result + FormatString(Copy(Line, StringBeginning,
                CharIndex - StringBeginning + 1));
            end;
          end;
        end;
      ctCode:
        begin
          EndOfCode := False;
          if TestStringBeginning then begin
            EndOfCode := True;
          end else if Line[CharIndex] = '#' then begin
            EndOfCode := True;
            CodeType := ctChar;
            StringBeginning := CharIndex;
          end else if TestCommentStart then begin
            EndOfCode := True;
          end else if not (Line[CharIndex] in AlphaNumeric) then begin
            EndOfCode := True;
            CodeType := ctWhiteSpace;
            WhiteSpaceBeginning := CharIndex;
          end;
          if EndOfCode then begin
            result := result + FormatCode(Copy(Line, CodeBeginning, CharIndex -
              CodeBeginning));
          end;
        end;
      ctEndString:
        begin
          if Line[CharIndex] = '#' then begin
            CodeType := ctChar;
          end else if TestCommentStart then begin
            // do nothing
          end else if Line[CharIndex] = '$' Then Begin
            CodeType := ctHex;
            HexBeginning := CharIndex;
          end else if Line[CharIndex] in Numeric then begin
            CodeType := ctNumeric;
            NumBeginning := CharIndex;
          end else if Line[CharIndex] in AlphaNumeric then begin
            CodeType := ctCode;
            CodeBeginning := CharIndex;
          end else begin
            CodeType := ctWhiteSpace;
            WhiteSpaceBeginning := CharIndex;
          end;
        end;
      ctChar:
        begin
          if Line[CharIndex] = '''' then begin
            CodeType := ctString;
          end else if TestCommentStart then begin
            // do nothing
          end else if Line[CharIndex] in Separators then begin
            result := result + FormatString(Copy(Line, StringBeginning,
              CharIndex - StringBeginning));
            CodeType := ctWhiteSpace;
            WhiteSpaceBeginning := CharIndex;
          end;
        end;
      ctParenComment:
        begin
          if Line[CharIndex] = ')' then begin
            if (CharIndex > 1) and (Line[CharIndex - 1] = '*') then begin
              CodeType := ctEndComment;
              result := result + FormatComment(Copy(Line, CommentBegining,
                CharIndex - CommentBegining + 1));
            end;
          end;
        end;
      ctBracketComment:
        begin
          if Line[CharIndex] = '}' then begin
            CodeType := ctEndComment;
            result := result + FormatComment(Copy(Line, CommentBegining,
              CharIndex - CommentBegining + 1));
          end;
        end;
      ctCompilerComment:
        begin
          if Line[CharIndex] = '}' then begin
            CodeType := ctEndComment;
            result := result + FormatCompilerComment(Copy(Line, CommentBegining,
              CharIndex - CommentBegining + 1));
          end;
        end;
      ctSlashComment:
        begin
          if Line[CharIndex] in LineEnd then begin
            CodeType := ctWhiteSpace;
            result := result + FormatComment(Copy(Line, CommentBegining,
              CharIndex - CommentBegining));
            WhiteSpaceBeginning := CharIndex;
          end;
        end;
      ctEndComment:
        begin
          if TestCommentStart then begin
            // do nothing
          end else if Line[CharIndex] in Separators then begin
            CodeType := ctWhiteSpace;
            WhiteSpaceBeginning := CharIndex;
          end else if Line[CharIndex] = '$' then begin
            CodeType := ctHex;
            HexBeginning := CharIndex;
          end else if Line[CharIndex] in Numeric then begin
            CodeType := ctNumeric;
            NumBeginning := CharIndex;
          end else if Line[CharIndex] in AlphaNumeric then begin
            CodeType := ctCode;
            CodeBeginning := CharIndex;
          end;
        end;
      ctHex:
        begin
          If (Line[CharIndex] in (Separators)) Or Not(Line[CharIndex] in Hexadec) then begin
            CodeType := ctEndHex;
            result := result + FormatHex(Copy(Line, HexBeginning,
                      CharIndex - HexBeginning));
            result := result + FormatCode(Copy(Line, CharIndex, 1));
          end;
        end;
      ctNumeric:
        begin
          If (Line[CharIndex] in (Separators - ['.'])) Or Not(Line[CharIndex] in Numeric) then begin
            CodeType := ctEndNumeric;
            If Pos('.', Copy(Line, NumBeginning, CharIndex - NumBeginning)) > 0 Then Begin
              NumberSubBlock := Copy(Line, NumBeginning, CharIndex - NumBeginning);
              NumberRange := Pos('..', NumberSubBlock);
              If NumberRange > 0 Then Begin
                result := result + FormatNumeric(
                          Copy(NumberSubBlock, 1, NumberRange - 1));
                result := result + FormatCode(
                          Copy(NumberSubBlock, NumberRange, Length(NumberSubBlock)));
              End Else
                result := result + FormatFloat(NumberSubBlock);
            End Else
              result := result + FormatNumeric(Copy(Line, NumBeginning,
                        CharIndex - NumBeginning));
            result := result + FormatCode(Copy(Line, CharIndex, 1));
          end;
        End;
      ctEndHex:
        begin
          if Line[CharIndex] = '#' then begin
            CodeType := ctChar;
          end else if TestCommentStart then begin
            // do nothing
          end else if Line[CharIndex] in Numeric then begin
            CodeType := ctNumeric;
            NumBeginning := CharIndex;
          end else if Line[CharIndex] in AlphaNumeric then begin
            CodeType := ctCode;
            CodeBeginning := CharIndex;
          end else begin
            CodeType := ctWhiteSpace;
            WhiteSpaceBeginning := CharIndex;
          end;
        end;
      ctEndNumeric:
        begin
          if Line[CharIndex] = '#' then begin
            CodeType := ctChar;
          end else if TestCommentStart then begin
            // do nothing
          end else if Line[CharIndex] = '$' Then Begin
            CodeType := ctHex;
            HexBeginning := CharIndex;
          End else if Line[CharIndex] in AlphaNumeric then begin
            CodeType := ctCode;
            CodeBeginning := CharIndex;
          end else begin
            CodeType := ctWhiteSpace;
            WhiteSpaceBeginning := CharIndex;
          end;
        end;
    else
      Assert(False);
    end;
  end;
  CharIndex := Length(Line) + 1;
  case CodeType of
    ctWhiteSpace:
      begin
        result := result + (Copy(Line, WhiteSpaceBeginning, CharIndex -
          WhiteSpaceBeginning));
      end;
    ctString:
      begin
      end;
    ctCode:
      begin
        result := result + FormatCode(Copy(Line, CodeBeginning, CharIndex -
          CodeBeginning));
      end;
    ctEndString:
      begin
      end;
    ctChar:
      begin
        result := result + FormatString(Copy(Line, StringBeginning,
          CharIndex - StringBeginning));
      end;
    ctParenComment:
      begin
        result := result + FormatComment(Copy(Line, CommentBegining,
          CharIndex - CommentBegining));
      end;
    ctBracketComment:
      begin
        result := result + FormatComment(Copy(Line, CommentBegining,
          CharIndex - CommentBegining));
      end;
    ctCompilerComment:
      begin
        result := result + FormatCompilerComment(Copy(Line, CommentBegining,
          CharIndex - CommentBegining));
      end;
    ctSlashComment:
      begin
      end;
    ctEndComment:
      begin
        result := result + FormatComment(Copy(Line, CommentBegining,
          CharIndex - CommentBegining));
      end;
    ctHex:
      begin
      end;
    ctEndHex:
      begin
      end;
    ctNumeric:
      begin
      end;
    ctEndNumeric:
      begin
      end;
  else Assert(False);
  end;
end;

function TDocGenerator.FormatNormalCode(AString: string): string;
begin
  Result := ConvertString(AString);
end;

function TDocGenerator.FormatComment(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.FormatHex(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.FormatNumeric(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.FormatFloat(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.FormatCompilerComment(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.FormatKeyWord(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.FormatString(AString: string): string;
begin
  result := ConvertString(AString);
end;

function TDocGenerator.Paragraph: string; 
begin
  Result := ' ';
end;

function TDocGenerator.ShortDash: string;
begin
  Result := '-';
end;

function TDocGenerator.EnDash: string;
begin
  Result := '--';
end;

function TDocGenerator.EmDash: string;
begin
  Result := '---';
end;

function TDocGenerator.HtmlString(const S: string): string;
begin
  Result := '';
end;

function TDocGenerator.LatexString(const S: string): string;
begin
  Result := '';
end;

function TDocGenerator.LineBreak: string; 
begin
  Result := '';
end;

function TDocGenerator.URLLink(const URL: string): string; 
begin
  Result := ConvertString(URL);
end;

function TDocGenerator.FormatBold(const Text: string): string;
begin
  Result := Text;
end;

function TDocGenerator.FormatItalic(const Text: string): string;
begin
  Result := Text;
end;

function TDocGenerator.FormatPreformatted(const Text: string): string;
begin
  Result := ConvertString(Text);
end;

function TDocGenerator.FormatTableOfContents(Sections: TDescriptionItem): string;
begin
  Result := '';
end;

function TDocGenerator.MakeItemLink(const Item: TBaseItem;
  const LinkCaption: string;
  const LinkContext: TLinkContext): string;
begin
  Result := ConvertString(LinkCaption);
end;

procedure TDocGenerator.WriteCodeWithLinksCommon(const Item: TPasItem;
  const Code: string; WriteItemLink: boolean;
  const NameLinkBegin, NameLinkEnd: string);
var
  NameFound, SearchForLink: Boolean;
  FoundItem: TBaseItem;
  i, j, l: Integer;
  s: string;
  pl: TStandardDirective;
  { ncstart marks what part of Code was already written:
    Code[1..ncstart - 1] is already written to output stream. }
  ncstart: Integer;
begin
  WriteStartOfCode;
  i := 1;
  NameFound := false;
  SearchForLink := False;
  l := Length(Code);
  ncstart := i;
  while i <= l do begin
    case Code[i] of
      '_', 'A'..'Z', 'a'..'z': 
        begin
          WriteConverted(Copy(Code, ncstart, i - ncstart));
          { assemble item }
          j := i;
          repeat
            Inc(i);
          until (i > l) or 
            (not (Code[i] in ['.', '_', '0'..'9', 'A'..'Z', 'a'..'z']));
          s := Copy(Code, j, i - j);

          if not NameFound and (s = Item.Name) then begin
            WriteDirect(NameLinkBegin);
            if WriteItemLink then
              WriteDirect(MakeItemLink(Item, s, lcCode)) else
              WriteConverted(s);
            WriteDirect(NameLinkEnd);
            NameFound := True;
          end else begin
            { Special processing for standard directives.

              Note that we check whether S is standard directive *after*
              we checked whether S matches P.Name, otherwise we would
              mistakenly think that 'register' is a standard directive
              in Code
                'procedure Register;'
              This shouldn't cause another problem (accidentally
              making standard directive a link, e.g. in code like
                'procedure Foo; register'
              or even
                'procedure Register; register;'
              ) because we safeguard against it using NameFound and
              SearchForLink state variables.

              That said, WriteCodeWithLinksCommon still remains a hackish
              excuse to not cooperate better with PasDoc_Parser when
              generating FullDeclaration of every item. }

            pl := StandardDirectiveByName(s);
            case pl of
              SD_ABSTRACT, SD_ASSEMBLER, SD_CDECL, SD_DYNAMIC, SD_EXPORT,
                SD_FAR, SD_FORWARD, SD_NAME, SD_NEAR, SD_OVERLOAD, SD_OVERRIDE,
                SD_PASCAL, SD_REGISTER, SD_SAFECALL, SD_STATIC,
                SD_STDCALL, SD_REINTRODUCE, SD_VIRTUAL:
                begin
                  WriteConverted(s);
                  SearchForLink := False;
                end;
              SD_EXTERNAL:
                begin
                  WriteConverted(s);
                  SearchForLink := true;
                end;
              else //case
                begin
                  if SearchForLink then
                    FoundItem := SearchItem(S, Item, false)
                  else
                    FoundItem := nil;

                  if Assigned(FoundItem) then
                    WriteDirect(MakeItemLink(FoundItem, s, lcCode))
                  else
                    WriteConverted(s);
                end;
            end;
          end;

          ncstart := i;
        end;
      ':', '=':
        begin
          SearchForLink := True;
          Inc(i);
        end;
      ';':
        begin
          SearchForLink := False;
          Inc(i);
        end;
      '''':
        begin
          { No need to worry here about the fact that 'foo''bar' is actually
            one string, "foo'bar". We will parse it in this procedure as
            two strings, 'foo', then 'bar' (missing the fact that ' is
            a part of string), but this doesn't harm us (as we don't
            need here the value of parsed string). }
          repeat
            Inc(i);
          until (i > l) or (Code[i] = '''');
          Inc(i);
        end;
      else Inc(i);
    end;
  end;
  WriteConverted(Copy(Code, ncstart, i - ncstart));
  WriteEndOfCode;
end;

procedure TDocGenerator.WriteExternal(
  const ExternalItem: TExternalItem;
  const Id: TTranslationID);
begin
  if not Assigned(ExternalItem) then
  begin
    Exit;
  end;

  DoMessage(2, pmtInformation, 'Writing Docs for %s, "%s"',
    [Language.Translation[Id], ExternalItem.Name]);

  If ExternalItem.Title = '' then begin
    ExternalItem.Title := Language.Translation[Id];
  end;

  If ExternalItem.ShortTitle = '' then begin
    ExternalItem.ShortTitle := ExternalItem.Title;
  end;

  WriteExternalCore(ExternalItem, Id);
end;

procedure TDocGenerator.WriteIntroduction;
begin
  WriteExternal(Introduction, trIntroduction);
end;

procedure TDocGenerator.WriteConclusion;
begin
  WriteExternal(Conclusion, trConclusion);
end;

procedure TDocGenerator.PreHandleAnchorTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  AnchorName: string;
  AnchorItem: TAnchorItem;
begin
  { We add AnchorName to FCurrentItem.Anchors in the 1st pass of expanding
    descriptions (i.e. in PreHandleAnchorTag instead of HandleAnchorTag),
    this way creating @links in the 2nd pass of expanding
    descriptions works good. }

  ReplaceStr := '';

  AnchorName := Trim(TagParameter);

  if not IsValidIdent(AnchorName) then begin
    ThisTag.TagManager.DoMessage(1, pmtWarning,
      'Invalid anchor name: "%s"', [AnchorName]);
    Exit;
  end;

  AnchorItem := (FCurrentItem as TExternalItem).AddAnchor(AnchorName);
  AnchorItem.FullLink := CreateLink(AnchorItem);
end;

procedure TDocGenerator.HandleAnchorTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  AnchorName: string;
begin
  { AnchorName is already added to FCurrentItem.Anchors,
    thanks to PreHandleAnchorTag.
    All we do here is to generate correct ReplaceStr. }

  AnchorName := Trim(TagParameter);

  if not IsValidIdent(AnchorName) then
    { Warning for this case was already printed by PreHandleAnchorTag.
      That's why here we do only Exit. }
    Exit;
  
  ReplaceStr := FormatAnchor(AnchorName);
end;

function TDocGenerator.SplitSectionTagParameters(
  ThisTag: TTag; const TagParameter: string; DoMessages: boolean;
  out HeadingLevel: integer; out AnchorName: string; out Caption: string):
  boolean;
var
  HeadingLevelString: string;
  Remainder: string;
begin
  Result := false;
  
  ExtractFirstWord(TagParameter, HeadingLevelString, Remainder);
  ExtractFirstWord(Remainder, AnchorName, Caption);
  
  try
    HeadingLevel := StrToInt(HeadingLevelString);
  except on E: EConvertError do
    begin
      if DoMessages then
        ThisTag.TagManager.DoMessage(1, pmtWarning,
          'Invalid heading level in @section tag: "%s". %s',
          [HeadingLevelString, E.Message]);
      Exit;
    end;
  end;

  if HeadingLevel < 1 then begin
    if DoMessages then
      ThisTag.TagManager.DoMessage(1, pmtWarning,
        'Invalid heading level in @section tag: %d. Heading level must be >= 1',
        [HeadingLevel]);
    Exit;
  end;

  Result := true;
end;

procedure TDocGenerator.PreHandleSectionTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  AnchorName: string;
  Caption: string;
  AnchorItem: TAnchorItem;
  HeadingLevel: integer;
begin
  { We add AnchorName to FCurrentItem.Anchors in the 1st pass of expanding
    descriptions (i.e. in PreHandleSectionTag instead of HandleSectionTag),
    this way creating @links in the 2nd pass of expanding
    descriptions works good. 
    
    Also, we can handle @tableOfContents in the 2nd pass. }
    
  ReplaceStr := '';

  if SplitSectionTagParameters(ThisTag, TagParameter, false,
    HeadingLevel, AnchorName, Caption) then
  begin
    AnchorItem := (FCurrentItem as TExternalItem).AddAnchor(AnchorName);
    AnchorItem.FullLink := CreateLink(AnchorItem);
    AnchorItem.SectionLevel := HeadingLevel;
    AnchorItem.SectionCaption := Caption;
  end;
end;

procedure TDocGenerator.HandleSectionTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  AnchorName: string;
  Caption: string;
  HeadingLevel: integer;
begin
  if SplitSectionTagParameters(ThisTag, TagParameter, true,
    HeadingLevel, AnchorName, Caption) then
  begin
    ReplaceStr := FormatSection(HeadingLevel, AnchorName, Caption);
  end;

  { Section is already added to FCurrentItem.Anchors,
    thanks to PreHandleSectionTag. }
end;

procedure TDocGenerator.TagAllowedInsideLists(
  ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
begin
  Allowed :=
    (EnclosingTag = OrderedListTag) or
    (EnclosingTag = UnorderedListTag) or
    (EnclosingTag = DefinitionListTag);
end;

procedure TDocGenerator.ItemLabelTagAllowedInside(
  ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
begin
  Allowed := EnclosingTag = DefinitionListTag;
end;

procedure TDocGenerator.TagAllowedInsideTable(
  ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
begin
  Allowed := EnclosingTag = TableTag;
end;

procedure TDocGenerator.TagAllowedInsideRows(
  ThisTag: TTag; EnclosingTag: TTag; var Allowed: boolean);
begin
  Allowed :=
    (EnclosingTag = RowTag) or
    (EnclosingTag = RowHeadTag);
end;

procedure TDocGenerator.HandleImageTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  I: Integer;
  FileNames: TStringList;
begin
  FileNames := TStringList.Create;
  try
    FileNames.Text := TagParameter;

    { Trim, remove empty lines, and expand paths on FileNames }
    I := 0;
    while I < FileNames.Count do begin
      FileNames[I] := Trim(FileNames[I]);
      if FileNames[I] = '' then
        FileNames.Delete(I)
      else begin
        FileNames[I] := CombinePaths(FCurrentItem.BasePath, FileNames[I]);
        Inc(I);
      end;
    end;

    if FileNames.Count = 0 then begin
      ThisTag.TagManager.DoMessage(1, pmtWarning,
        'No parameters for @image tag', []);
    end else
      ReplaceStr := FormatImage(FileNames);
  finally
    FileNames.Free
  end;
end;

function TDocGenerator.FormatImage(FileNames: TStringList): string;
begin
  Result := ExpandFileName(FileNames[0]);
end;

procedure TDocGenerator.HandleIncludeTag(
  ThisTag: TTag; var ThisTagData: TObject;
  EnclosingTag: TTag; var EnclosingTagData: TObject;
  const TagParameter: string; var ReplaceStr: string);
var
  IncludedText: string;
begin
  IncludedText := FileToString(CombinePaths(FCurrentItem.BasePath, Trim(TagParameter)));
  ReplaceStr := ThisTag.TagManager.Execute(IncludedText,
    { Note that this means that we reset auto-linking state
      inside the include file to what was chosen by --auto-link
      command-line option. I.e.,
        @noAutoLink(@include(file.txt))
      does NOT turn auto-linking off inside file.txt. }
    AutoLink);
end;

//heading for (possibly named) member lists.
function  TDocGenerator.GetMemberSectionHeading(items: TDescriptionItem): string;
var
  s, t: string;
begin
  s := Language.Translation[Items.id];
  if items.Value <> '' then
    t := Items.Value //preferred: group description
  else
    t := Items.Name; //last resort: group name
  if t <> '' then
    s := s + ' - ' + t; //combine group type and description
  Result := s;
end;

end.
